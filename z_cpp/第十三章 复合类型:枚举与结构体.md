# 第十三章 复合类型:枚举与结构体

## 13.0 用户自定义类型简介

基本类型被定义为C++语言核心的一部分，所以它们可以直接使用。如果要定义类型为int或double的变量，可以这样做：

```c++
int x; //定义基本类型int的变量
double d; //定义类型 double的变量
```

基本类型（包括函数、指针、引用和数组）简单扩展的复合类型也是如此：

```
void fcn(int) {}; // 定义类型为 void()(int) 的函数
int* ptr; // 定义类型为 'int 指针' 的变量
int& ref { x }; // 定义类型为 'int引用' 的变量
int arr[5]; // 定义有五个int的数组，类型为 int[5] (后续章节介绍)
```

这是可行的，因为C++语言已经知道这些类型名称（和符号）意味着什么——不需要提供或导入任何定义。

### 1、程序定义的类型

程序定义的类型必须在使用之前定义。

尽管我们还没有介绍结构体是什么，但下面的示例显示了自定义的Fraction类型，和使用该类型实例化对象：

```
// 定义一个类型 Fraction，让编译器知道 Fraction 由什么组成
// (后续章节介绍 struct 如何使用)
// 这里只是说明 Fraction 的组成方式，并不实际创建一个对象
struct Fraction{
	int numerator {};
	int denominator {};
};

// 现在可以使用 Fraction 类型
int main()
{
	Fraction f{ 3, 4 }; // 实例化一个类型 Fraction 的变量 f
	return 0;
}
```

### 2、程序定义类型的命名惯例

按照惯例，程序定义的类型以大写字母开头命名，并且不使用后缀（例如，Fraction，而不是 fraction、Fraction_t、fraction_t）。

由于类型名和变量名之间的相似性，新程序员有时会发现如下变量定义令人困惑：

```
Fraction fraction {}; // 实例化一个类型为 Fraction 的变量 fraction
```

这与任何其他变量定义没有什么不同：首先是类型（Fraction）（因为Fraction是大写的，所以我们知道它是程序定义的类型），然后是变量名（fraction），最后是可选的初始值设定项。因为C++是区分大小写的，所以这里没有命名冲突！

> 以大写字母开头命名程序定义的类型，不要使用后缀。

### 3、在多文件程序中使用程序定义类型

使用程序定义类型的每个代码文件都需要在使用之前查看到完整的类型定义。前向声明是不够的。这是必需的，以便编译器知道为该类型的对象分配多少内存。

为了将类型定义传播到需要它们的代码文件中，通常在头文件中放置程序定义的类型，然后将其#include包含到需要该类型定义的任何代码文件中。这些头文件通常具有与程序定义类型相同的名称（例如，名为Fraction的程序定义类型将在fraction.h中定义）

下面是一个示例，将Fraction类型移动到头文件（名为fraction.h）中，以便它可以被包含在多个代码文件中：

fraction.h：

```
#ifndef FRACTION_H
#define FRACTION_H
/ 定义一个新类型 Fraction
// 这只是类型定义，并不实际创建对象
// 注意这是完整的声明，而不是前向声明
struct Fraction
{
	int numerator {};
	int denominator {};
};

#endif
```

fraction.cpp：

```C++
#include "fraction.h" // 在这里导入 Fraction 的定义

// 现在可以使用 Fraction 类型
int main()
{
	Fraction f{ 3, 4 }; // 创建一个类型为 Fraction 的对象 f

	return 0;
}
```

> 如果自定义类型仅在一个代码文件中使用，则在该文件中定义，并且定义尽可能靠近第一个使用点。
>
> 在多个文件中使用的自定义类型，应在与类型同名的头文件中定义，然后根据需要 #include 到每个代码文件中。

## 13.1 非限定作用域枚举

C++包含许多有用的基本数据类型和复合数据类型。但对于我们想要做的事情，这些类型并不总是足够的。

例如，在程序中，需要记录苹果是红色、黄色还是绿色，或者衬衫是什么颜色。如果只有基本类型可用，应该如何做到这一点？或许可以使用某种隐式映射（0=红色，1=绿色，2=蓝色）将颜色存储为整数值：

```
int main()
{
    int appleColor{ 0 }; // 苹果是红色
    int shirtColor{ 1 }; // 衬衫是绿色

    return 0;
}
```

但这一点也不直观，并且在代码中使用魔数是有害的。可以通过使用constexpr变量来去除魔数：

```
constexpr int red{ 0 };
constexpr int green{ 1 };
constexpr int blue{ 2 };

int main()
{
    int appleColor{ red };
    int shirtColor{ green };

    return 0;
}
```

虽然这对于可读性更好一些，但程序员仍然需要判断appleColor和shirtColor（类型为int），是指保存在颜色符号的集合里的一个（它们可能在别处定义，在单独的文件中定义）。

> 如果有能力定义自定义类型，可以定义与该类型相关联的值的集合，那么将有完美的工具来优雅地解决上面的挑战。

### 1、枚举

枚举（也称为枚举类型）是一种复合数据类型，其值限制为一组命名符号常量（）。

C++支持两种枚举：**非限定作用域枚举**（我们现在将讨论）和**限定作用域枚举**（在本章后面将讨论）。

因为枚举是程序定义的类型，所以每个枚举都需要在使用之前完全定义（前向声明是不够的）。

### 2、非限定作用域枚举

非限定作用域枚举是通过enum关键字定义的。

枚举类型最好通过示例来教授，所以让我们定义一个可以保存一些颜色值的非限定作用域枚举。将在下面解释它是如何工作的。

```
// 定义名为 Color 的非限定作用域枚举
enum Color{
	red,
	green,
	blue, 
};

int main()
{
    // 定义Color类型的一些变量
    Color apple { red };   // 苹果是红色
    Color shirt { green }; // 衬衫是绿色
    Color cup { blue };    // 杯子是蓝色

    Color socks { white }; // 错误: white 不是 Color 定义的枚举元素
    Color hat { 2 };       // 错误: 2 不是 Color 定义的枚举元素

    return 0;
}
```

通过使用enum关键字来开始，告诉编译器正在定义一个非限定作用域枚举，将其命名为Color。

在一对花括号内，为颜色类型定义枚举元素：red、green和blue。它们定义了类型Color限制的特定值。每个枚举元素必须用逗号（不是分号）分隔–最后一个元素后面的尾随逗号是可选的，但建议使用以保持一致性。

> 在一对花括号内，为颜色类型定义枚举元素：red、green和blue。它们定义了类型Color限制的特定值。每个枚举元素必须用逗号（不是分号）分隔–最后一个元素后面的尾随逗号是可选的，但建议使用以保持一致性。

### 3、使用枚举

由于枚举元素是描述性的，因此它们对于增强代码可读性非常有用。当有一组很小的相关常量时，最好使用枚举类型。

通常定义的枚举包括一周中的几天、基本方向和一副卡片中的套装：

```c++
enum DaysOfWeek
{
    sunday,
    monday,
    tuesday,
    wednesday,
    thursday,
    friday,
    saturday,
};

enum CardinalDirections
{
    north,
    east,
    south,
    west,
};

enum CardSuits
{
    clubs,
    diamonds,
    hearts,
    spades,
};
```

有时，函数将向调用方返回状态代码，以指示函数是成功执行还是遇到错误。传统上，小负数用于表示不同的可能错误代码。例如：

```c++
int readFileContents()
{
    if (!openFile())
        return -1;
    if (!readFile())
        return -2;
    if (!parseFile())
        return -3;

    return 0; // success
}
```

然而，像这样使用魔数并不是很有描述性的。更好的方法是使用枚举类型：

```
enum FileReadResult
{
    readResultSuccess,
    readResultErrorFileOpen,
    readResultErrorFileRead,
    readResultErrorFileParse,
};

FileReadResult readFileContents()
{
    if (!openFile())
        return readResultErrorFileOpen;
    if (!readFile())
        return readResultErrorFileRead;
    if (!parseFile())
        return readResultErrorFileParse;

    return readResultSuccess;
}
```

然后调用方可以测试返回值是哪个枚举元素，这比测试特定整数值的返回结果更容易理解。

```
if (readFileContents() == readResultSuccess)
{
    // do something
}
else
{
    // print error message
}
```

枚举类型也可以在游戏编程中很好地使用，以识别不同类型的物品、怪物或地形。基本上，任何东西都是一组相关的元素。

```
enum ItemType
{
	sword,
	torch,
	potion,
};

int main()
{
	ItemType holding{ torch };

	return 0;
}
```

由于枚举很小，并且复制成本很低，因此可以通过值传递（并返回）它们。

### 4、非限定作用域枚举的作用域
