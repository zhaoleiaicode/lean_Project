## 14.0 面向对象编程简介

### 1.面向过程编程

在前面，我们在 C++中将对象定义为“一块可用于存储值的内存”。具有名称的对象称为变量。C++程序由发送到计算机的指令的顺序列表组成，这些指令定义数据（通过对象）和对该数据执行的操作（通过语句和表达式组成的函数）。

到目前为止，我们一直在做一种称为面向过程编程的行为。在其中，重点是创建实现程序逻辑的“过程”（在 C++中称为函数）。将数据对象传递给这些函数，这些函数对数据执行操作，然后可能返回一个结果供调用方使用。

在过程编程中，函数和这些函数操作的数据是单独的实体。程序员负责将函数和数据组合在一起，以产生所需的结果。这导致代码如下所示：

```c++
eat(you, apple); 
```

现在，看看你周围的一切——你看到的每一个地方都是物体：书籍、建筑物、食物，甚至你。这类对象有两个主要组成部分：1）一些相关的属性（例如重量、颜色、大小、坚固性、形状等），以及 2）它们可以表现的一些行为（例如打开、使其他东西变热等）。这些属性和行为是不可分割的。

>[!warning]
>
>在编程中，属性由对象表示，行为由函数表示。因此，过程编程比较糟糕地描述了现实，因为它分离了属性（对象）和行为（函数）。

### 2.什么是面向对象编程？

在面向对象编程（object-oriented programming，通常缩写为 OOP）中，重点是创建合适的数据类型，里面包含对应的属性以及一组良好的行为函数。OOP 中的术语“对象”是指可以从此类型中实例化的对象。

这导致代码看起来更像：

```c++
you.eat(apple); 
```

这使得行为主体（you）、正在调用什么行为（eat）以及哪些对象是该行为的附件（apple）变得更清楚。

因为属性和行为不再是分开的，所以对象更容易模块化，这使得程序更容易编写和理解，并且还提供了更高程度的代码重用性。通过定义对象之间如何互相交互，这提供了一种更直观的处理数据的方法。

在下一课中，将讨论如何创建此类对象。

### 3.面向过程与面向对象程序示例

下面是一个面向过程风格的程序，打印动物的名称和腿的数量：

```C++
#include <iostream>
#include <string_view>

enum AnimalType
{
    cat,
    dog,
    chicken,
};

constexpr std::string_view animalName(AnimalType type)
{
    switch (type)
    {
    case cat: return "cat";
    case dog: return "dog";
    case chicken: return "chicken";
    default:  return "";
    }
}

constexpr int numLegs(AnimalType type)
{
    switch (type)
    {
    case cat: return 4;
    case dog: return 4;
    case chicken: return 2;
    default:  return 0;
    }
}


int main()
{
    constexpr AnimalType animal{ cat };
    std::cout << "A " << animalName(animal) << " has " << numLegs(animal) << " legs\n";

    return 0;
}
```

在这个程序中，编写了一些函数，这些函数允许我们做一些事情，如获取动物的腿数，以及获取动物的名称。

虽然这很好，但考虑一下当想更新这个程序时会发生什么，如果想添加动物蛇。向代码中添加蛇，需要修改 AnimalType、numLegs()和 animalName()。如果这是一个大的代码库，还需要更新使用 AnimalType 的任何其他相关函数——如果 AnimalType 在许多地方使用，那么可能有许多代码需要修改（很容易引入错误）

现在，让我们使用 OOP 思维来编写相同的程序（产生相同的输出）：

```C++
#include <iostream>
#include <string_view>

struct Cat
{
    std::string_view name{ "cat" };
    int numLegs{ 4 };
};

struct Dog
{
    std::string_view name{ "dog" };
    int numLegs{ 4 };
};

struct Chicken
{
    std::string_view name{ "chicken" };
    int numLegs{ 2 };
};

int main()
{
    constexpr Cat animal;
    std::cout << "a " << animal.name << " has " << animal.numLegs << " legs\n";

    return 0;
}
```

在本例中，每个动物都是其自己的类型，并且该类型管理与该动物相关的所有内容。

现在考虑这样一个情况，如果想添加动物蛇。我们所要做的就是创建一个蛇类型。几乎不需要更改现有代码，这意味着破坏已经工作的代码的风险要小得多。

上面的猫、狗和鸡示例有许多重复（因为每个都定义了完全相同的成员集）。在这种情况下，创建通用的 Animal 结构并为每个动物创建实例可能更可取。但如果我们想向 Chicken 添加一个不适用于其他动物的新成员（例如，每天下蛋的个数），该怎么办？在后面会介绍，通过使用 OOP 模型，我们可以将该成员限制为只属于 Chicken 对象。

### 4.OOP 带来了其他好处

在学校，当你提交编程作业时，你的工作基本上已经完成。您的老师或助教将运行您的代码，以查看它是否产生正确的结果。根据运行结果，你会相应地被评分。然后您的代码大概率会被丢弃。

在实际工作中，当您将代码提交到其他开发人员使用的代码库中，或提交到真实用户使用的应用程序中时，这是一种完全不同的情况。一些新的操作系统或软件版本将破坏您的代码。用户将发现您所犯的一些逻辑错误。业务合作伙伴将需要一些新的功能。其他开发人员将需要在不破坏代码的情况下扩展您的代码。您的代码需要能够进化，并且它需要能够以最小的时间投入、最小的头痛和最小的破坏来做到这一点。

解决这些问题的最佳方法是尽可能保持代码的模块化（和非冗余）。为了帮助实现这一点，OOP 还引入了许多其他有用的概念：继承、封装、抽象和多态。

我们将在适当的时候讨论所有这些都是什么，以及它们如何帮助减少代码的冗余，并更容易修改和扩展。一旦您正确地熟悉了 OOP 并使用了它，您可能永远不会想再回到纯过程编程。

也就是说，OOP 并不能取代过程编程——相反，它在编程工具带中为您提供了额外的工具，以帮助在需要时管理复杂性。

### 5.术语“对象”

请注意，术语“对象”在不同地方有不同的含义，这会导致一定程度的混淆。在传统编程中，对象是存储值的存储空间。在面向对象编程中，“对象”意味着它既是传统编程意义上的对象，又是属性和行为的组合。在本教程中，将倾向于术语对象的传统含义，并在特别提到 OOP 对象时更倾向于术语“类对象”。

## 14.1 class 简介

在前一章中，我们介绍了结构体。它可以将多个成员变量绑定到单个对象（可以作为一个单元进行初始化和传递）。换句话说，结构体提供了一个方便的封装形式，来存储和移动相关的数据值。

考虑以下结构：

```c++
#include

struct Date
{
    int day{};
    int month{};
    int year{};
};

void printDate(const Date& date)
{
    std::cout << date.day << '/' << date.month << '/' << date.year; // 设置 DMY 的格式
}

int main()
{
    Date date {4,10,21};
    printDate(date);
    return 0;
}
```

在上面的示例中，创建了一个 Date 对象，然后将其传递给打印日期的函数。该程序打印：

```shell
4/10/21 
```

尽管结构体很有用，但有许多缺陷，在试图构建大型复杂程序（特别是由多个开发人员处理的程序）时，这些缺陷可能会带来挑战。

### 1.数据状态有效性问题

结构体最大的问题，是没有办法确保结构体内的数据一定是有效的。在前面，我们学习过不变量的定义，即“在某个组件执行时必须为真的条件”。

在类类型（包括结构体、类和联合）的情况下，类不变量是一个条件，必须在对象的整个生存期内为真，以便对象保持有效状态。违反的类不变量的对象被称为处于无效状态，使用该对象可能会导致意外或未定义的行为。

首先，考虑以下结构体：

```C++
struct Pair
{
    int first {};
    int second {};
};
```

第一个和第二个成员可以独立设置为任何值，因此 Pair 结构没有不变量。

现在考虑以下表示分数的几乎相同的结构体：

```C++
struct Fraction
{
    int numerator { 0 };
    int denominator { 1 };
};
```

分母为 0 的分数在数学上是无效的（因为分数的值是其分子除以分母——除以 0 在数学上没有定义）。因此，需要确保 Fraction 对象的 denominator 成员不会设置为 0。

例如：

```C++
#include <iostream>

struct Fraction
{
    int numerator { 0 };
    int denominator { 1 }; // 默认初始化: 初始化为有效值
};

void printFractionValue(const Fraction& f)
{
     std::cout << f.numerator / f.denominator << '\n';
}

int main()
{
    Fraction f { 5, 0 };   // 创建一个分母为0的分数
    printFractionValue(f); // 会导致除0错误

    return 0;
}
```

在上面的例子中，使用注释来记录 Fraction 的不变量。还提供了一个默认的成员初始值，以确保在用户不提供初始化值的情况下将分母设置为 1。这确保了当用户决定对 Fraction 对象进行值初始化时，Fraction object 将有效。这是一个好的开始。

但没有什么可以阻止显式地违反这个类不变量：当创建分数 f 时，可以使用聚合初始化来显式地将分母初始化为 0。虽然这不会立即导致问题，但对象现在处于无效状态，进一步使用该对象可能会导致意外或未定义的行为。

当调用 printFractionValue(f)时：程序由于除零错误而终止。

考虑到 Fraction 示例的相对简单性，简单地避免创建无效的 Fraction 对象应该不会太困难。然而，在使用许多结构体、具有许多成员的结构体或其成员具有复杂关系的更复杂的代码库中，理解哪些值组合可能违反某些类不变量可能不是那么明显。

一个小的改进是在 printFractionValue 函数的头部使用断言 assert(f.denominator != 0); 。然而，从行为上来说，这并没有真正改变任何事情。我们应该做到的是避免出错。

### 2.class 简介

在开发 C++时，Bjarne Stroustrup 希望引入一些功能，允许开发人员创建可以更直观地使用的程序定义类型。他还对为困扰大型复杂程序的一些常见缺陷和维护挑战（如前面提到的类不变量问题）寻找优雅的解决方案感兴趣。

根据他在其他编程语言（特别是 Simula，第一个面向对象的编程语言）方面的经验，Bjarne 确信，开发一种程序定义的类型是可能的，它是通用的，功能强大，足以用于几乎任何事情。在向 Simula 学习时，他将这种类型称为类（class）。

就像结构体一样，类是程序定义的复合类型，可以有许多具有不同类型的成员变量。

>[!Note]
>
>从技术角度来看，结构体和类几乎是相同的——因此，使用结构体实现的任何示例都可以使用类实现，反之亦然。然而，从实践的角度来看，我们使用结构体和类的方式不同。
>
>我们在后面讨论具体技术和实践差异

### 3.定义类

由于类是程序定义的数据类型，因此必须在使用之前定义它。类的定义类似于结构体，只是我们使用 class 关键字而不是 struct。例如，下面是 Employee 类的定义：

```c++
class Employee
{
	int m_id{};
	int m_age{};
	double m_wage{};
};
```

为了演示相似的类和结构体可以有多相似，下面的程序等效于在课程顶部介绍的程序，但 Date 现在是一个类，而不是结构：

```C++
#include <iostream>

class Date       // 将 struct 替换为 class
{
public:          // 这里行，是一个访问说明符
    int m_day{}; // 为成员变量，添加 "m_" 前缀
    int m_month{};
    int m_year{};
};

void printDate(const Date& date)
{
    std::cout << date.m_day << '/' << date.m_month << '/' << date.m_year;
}

int main()
{
    Date date{ 4, 10, 21 };
    printDate(date);

    return 0;
}
```

这将打印：

```c++
4/10/21 
```

>[!note]
>
>在后面，会解释为什么类的成员变量通常以“m_”为前缀，同时会介绍访问说明符是什么

### 4.大多数 C++标准库都是类

您已经在使用过类对象。std:: string 和 std:: string_view 都被定义为类。事实上，标准库中的大多数非别名类型都定义为类！

类确实是 C++的核心和灵魂——它们是如此基础，以至于 C++最初被命名为“带类的 C”！一旦您熟悉了类，您在 C++中的大部分时间都将用于编写、测试和使用它们。

## 14.2 成员函数

### 1.成员函数

除了有成员变量之外，类类型（包括结构体、类和联合）也可以有自己的函数！属于类类型的函数称为成员函数。

不是成员函数的函数被称为非成员函数，以将它们与成员函数区分开来。上面的 print()函数是一个非成员函数。

成员函数必须在类类型定义内部声明，可以在类类型内部或外部定义。提醒一下，定义也是声明，因此如果在类中定义成员函数，它将被视为声明。

### 2.成员函数示例

让我们重写课程顶部的 Date 示例，将 print()从非成员函数转换为成员函数：

```C++
// 成员函数版本
#include <iostream>

struct Date
{
    int year {};
    int month {};
    int day {};

    void print() // 定义了成员函数 print
    {
        std::cout << year << '/' << month << '/' << day;
    }
};

int main()
{
    Date today { 2020, 10, 14 }; // 结构体聚合初始化

    today.day = 16; // 使用 (.) 来访问成员变量
    today.print();  // 使用 (.) 来访问成员函数

    return 0;
}
```

该程序编译并产生与上面相同的结果：

```shell
2020/10/16 
```

> 成员函数与非成员函数示例之间有三个关键区别：
>
> 1. 声明与定义 print() 函数的位置
> 2. 如何调用 print() 函数
> 3. 如果在 print() 函数中访问成员变量

### 3.成员变量和函数可以按任何顺序定义

C++编译器通常从上到下编译代码。对于遇到的每个名称，编译器会检查它是否已经看到该名称的声明，以便它可以进行适当的类型检查。

这意味着在非成员函数内部，不能使用未在之前声明的变量或函数：

```C++
void x()
{
    y(); // error: y 没有声明, 编译器无法得知y是什么
}
 
int y()
{
    return 5;
}
```

然而，在类类型内部，对于成员函数和成员变量，这个限制不适用，可以按自己喜欢的顺序定义成员。例如：

```C++
struct Foo
{
    int m_x{ y() };   // 这里可以调用 y()，即使 y 在这里仍未被定义

    void x() { y(); } // 这里可以调用 y()，即使 y 在这里仍未被定义
    int y()  { return 5; }
};
```

4.成员函数可以重载

就像非成员函数一样，成员函数也可以重载，只要每个成员函数之间可以区分。

```C++
#include <iostream>
#include <string_view>

struct Date
{
    int year {};
    int month {};
    int day {};

    void print()
    {
        std::cout << year << '/' << month << '/' << day;
    }

    void print(std::string_view prefix)
    {
        std::cout << prefix << year << '/' << month << '/' << day;
    }
};

int main()
{
    Date today { 2020, 10, 14 };

    today.print(); // 调用 Date::print()
    std::cout << '\n';

    today.print("The date is: "); // 调用 Date::print(std::string_view)
    std::cout << '\n';

    return 0;
}
```

这将打印：

```C++
2020/10/14
The date is: 2020/10/14
```

## 14.3 Const类对象和Const成员函数

