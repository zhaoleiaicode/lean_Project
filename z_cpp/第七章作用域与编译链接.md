

# 第七章:作用域与编译链接

## 7.1 自定义命名空间

在之前，我们介绍了命名冲突和命名空间的概念。提醒一下，当两个相同的标识符被引入同一作用域时，就会发生命名冲突，编译器无法决定使用哪个标识符。当这种情况发生时，编译器或链接器将产生错误，因为它们没有足够的信息来解决歧义。

> [!tip]
>
> 随着程序变得越来愈大，标识符的数量增加，这反过来导致发生命名冲突的概率显著增加。由于给定范围中的每个名称都可能与同一范围中的其他名称发生潜在冲突，因此标识符的线性增加将导致潜在冲突的指数增加！这是在尽可能小的范围内定义标识符的关键原因之一。

让我们重新查看命名冲突的示例，然后展示如何使用名称空间来改进。在下面的示例中，foo.cpp和goo.cpp 是包含执行不同操作但具有相同名称和参数的函数的源文件。

**foo.cpp:**

```cpp
// 这个 doSomething() 将参数相加
int doSomething(int x, int y)
{
    return x + y;
}
```

**goo.cpp:**

```c++
// 这个 doSomething() 将参数相减
int doSomething(int x, int y)
{
    return x - y;
}
```

**main.cpp：**

```c++
#include <iostream>

int doSomething(int x, int y); // 前向声明 doSomething

int main()
{
    std::cout << doSomething(4, 3) << '\n'; // 实际调用的是哪个 doSomething ?
    return 0;
}
```

如果该项目仅包含foo.cpp或goo.cpp之一（但不同时包含两者），则它将编译通过并运行，而不会发生意外。然而，将两者编译到同一个程序中，会将两个具有相同名称和参数的不同函数引入到同一作用域（全局作用域）中，这会导致命名冲突。因此，链接器将提示错误：

```
goo.cpp:3: multiple definition of `doSomething(int, int)'; foo.cpp:3: first defined here 
```

:tipping_hand_man:**请注意，此错误发生是因为重复定义，因此函数doSomething是否被调用并不重要**。

解决此问题的一种方法是重命名其中一个函数，以便名称不再冲突。但这也需要更改所有函数被调用的位置，很麻烦，并且容易出错。避免冲突的更好方法是将函数放入自己的命名空间中。基于这个原因，标准库被移动到std命名空间中。

## 7.2 局部变量

> #### **局部变量是在函数内定义的变量（包括函数参数）。**

在之前，我们还介绍了作用域的概念。标识符的作用域确定了可以在源代码中访问标识符的作用域。当一个标识符可以被访问时，我们说它在作用域内。当标识符不能被访问时，我们说它超出作用域。作用域是编译时属性，当标识符超出作用域时，尝试使用它将导致编译错误。

### **1、局部变量具有代码块作用域**

局部变量具有代码块作用域，这意味着从定义点到定义它们的代码块的末尾都在作用域内。

```c++
int main()
{
    int i { 5 }; // i 进入作用域
    double d { 4.0 }; // d 进入作用域

    return 0;
} // d 和 i 离开作用域
```

尽管函数参数没有在函数体内定义，但对于一般函数，它们可以被视为函数体内作用域的一部分。

```c++
int max(int x, int y) // x 和 y 进入作用域
{
    // 将x与y的最大值赋值给max
    int max{ (x > y) ? x : y }; // max 进入作用域

    return max;
} // max, y, x 离开作用域
```

### **2、作用域内的所有变量名都必须唯一**

变量名在给定作用域内必须唯一。考虑以下程序：

```C++
void someFunction(int x)
{
    int x{}; // 编译失败，x与参数名称冲突
}

int main()
{
    return 0;
}
```

### **3、局部变量具有自动存储期**

变量的存储期（storage duration）规则，决定了何时以及如何创建和销毁变量。在大多数情况下，变量的存储期规则直接决定其生命周期。

例如，局部变量具有自动存储期，这意味着它们在定义点创建，在定义它们的代码块末尾销毁。例如：

```c++
int main()
{
    int i { 5 }; // i 创建与初始化
    double d { 4.0 }; // d 创建与初始化

    return 0;
} // d i 在这里被销毁
```

### **4、嵌套代码块中的局部变量**

局部变量可以在嵌套块内定义。这与函数体块中的局部变量相同：

```
int main() // 外围代码块
{
    int x { 5 }; // x 进入作用域，并被创建

    { // 内层代码块
        int y { 7 }; // y 进入作用域，并被创建
    } // y 离开作用域，并被销毁

    // y 无法再被使用，因为离开了作用域

    return 0;
} // x 离开作用域，并被销毁
```

在上面的示例中，变量y在嵌套代码块中定义。它的作用域从定义点到嵌套块的末尾，并且其生命周期也相同。因为变量y的作用域限制在定义它的内部块中，所以它在外部块不可访问。

**5、变量应在最有限的作用域内定义**

如果变量仅在嵌套块中使用，则应在该嵌套块中定义：

```c++
#include <iostream>

int main()
{
    // 不要在这里定义y

    {
        // y 只在这个代码块内使用，所以在这里定义
        int y { 5 };
        std::cout << y << '\n';
    }

    // 后续不再使用y，所以没有必要能够看到y的定义

    return 0;
}
```

## 7.3 全局变量

> [!tip]
>
> 在C++中，变量也可以在函数外部声明。这样的变量称为全局变量。

### **1、声明全局变量**

按照惯例，全局变量在全局命名空间中的文件顶部、include的下方声明。下面是示例：

```c++
#include <iostream>

// 函数外的变量是全局变量
int g_x {}; // 全局变量 g_x

void doSomething()
{
    // 全局变量声明后，可以在文件内的任意位置看到和使用
    g_x = 3;
    std::cout << g_x << '\n';
}

int main()
{
    doSomething();
    std::cout << g_x << '\n';

    // 全局变量声明后，可以在文件内的任意位置看到和使用
    g_x = 5;
    std::cout << g_x << '\n';

    return 0;
}
// 文件结束，g_x离开作用域
```

### **2、全局变量的作用域**

> [!tip]
>
> 在全局名空间中声明的标识符具有全局命名空间作用域（通常称为全局作用域，有时非正式地称为文件作用域），这意味着它们从声明点到声明它们的文件末尾都是可见的。

一旦声明，全局变量就可以在文件中的任何位置使用！在上面的示例中，函数doSomething() 和main() 中都使用了全局变量 g_x。

全局变量也可以在用户定义的命名空间内定义。下面是与上面相同的示例，但g_x已从全局范围移动到用户定义的命名空间Foo：

```
#include <iostream>

namespace Foo // Foo 在全局命名空间中定义
{
    int g_x {}; // g_x 现在位于 Foo 命名空间中, 但仍是全局变量
}

void doSomething()
{
    // 全局变量声明后，可以在文件内的任意位置看到和使用
    Foo::g_x = 3;
    std::cout << Foo::g_x << '\n';
}

int main()
{
    doSomething();
    std::cout << Foo::g_x << '\n';

    // 全局变量声明后，可以在文件内的任意位置看到和使用
    Foo::g_x = 5;
    std::cout << Foo::g_x << '\n';

    return 0;
}
```

:bulb: **尽管上面的代码中标识符g_x现在被限制在命名空间Foo，但该名称仍然可以全局访问（通过Foo::g_x），g_x仍然是全局变量。**

> #### 在命名空间内声明的变量也是全局变量。

### **3、全局变量具有静态存储期**

全局变量在程序启动时创建，在程序结束时销毁。这称为静态存储期。具有静态存储期的变量有时称为静态变量。

 **命名全局变量**

按照惯例，一些开发人员在非常量的全局变量标识符前面加上“g”或“g_”，以表示它们是全局的。该前缀有几种用途：

1. 它有助于避免与全局命名空间中的其他标识符发生命名冲突。
2. 它有助于防止无意中的命名遮挡（name shadowing）（后续讨论）。
3. 它有助于指示变量存在于函数范围之外，因此，对它们所做的任何更改也将持续存在。

> [!Important]
>
> 在命名非常量的全局变量时，请考虑使用“g”或“g_”前缀，以帮助将它们与局部变量和函数参数区分开来。

**全局变量初始化**

与局部变量（默认情况下未初始化）不同，具有静态存储期的变量默认为被零初始化。

也可以选择初始化非常量的全局变量：

```
int g_x; //未显示初始化
int g_y{}; //值初始化
int g_z{1}; //使用值初始化
```

## **7.4 变量名称遮挡**

> [!tip]
>
> 每个代码块有自己的变量命名的空间。那么，当我们在嵌套的内部块中有一个变量，该变量与外部块中的变量同名时，会发生什么呢？当这种情况发生时，嵌套块内的变量会“遮挡”外部变量。

### 1、局部变量名称遮挡

```c++
#include <iostream>

int main()
{ // 外围代码块
    int apples { 5 }; // 外围代码块中的 apples 变量

    { // 内层代码块
        // 这里的 apples 是外围的
        std::cout << apples << '\n'; // 打印外围的 apples 的值

        int apples{ 0 }; // 嵌套的代码块中的 apples 变量

        // apples 现在指代的是内层代码块里的变量
        // 外围的被遮挡住了

        apples = 10; // 内层的 apples 被赋值

        std::cout << apples << '\n'; // 打印内层的 apples的值
    } // 内层代码块中的apples被销毁


    std::cout << apples << '\n'; // 打印外围代码块中的 apples 变量

    return 0;
} // 外围代码块中的apples被销毁
```

如果运行此程序，它将打印：

```C++
5
10
5
```

在上面的程序中，我们首先在外部块中声明一个名为apples的变量。该变量在内部块中可见，我们可以通过打印其值（5）来查看。然后，我们在嵌套块中声明一个不同的变量（也称为apples）。从这一位置到块的末尾，名称apples是指嵌套块内的变量，而不是外部块。

因此，当我们将值10分配给apples时，我们将其分配给嵌套块内的apples。打印该值（10）后，嵌套块结束，嵌套块apples被销毁。外围块apples的存在和值不受影响，我们通过打印apples（5）的值来证明这一点。

:tipping_hand_man:==**请注意，如果未在嵌套块内新定义apples，则嵌套块中的apples仍然指外部块apples，因此将值10分配给apples将应用于外部块apples：**==

```c++
#include <iostream>

int main()
{ // 外围代码块
    int apples{5}; // 外围代码块中的 apples 变量

    { // 内层代码块
        // apples refers to outer block apples here
        std::cout << apples << '\n'; // 打印外围的 apples 的值

        // 这个例子不定义内层的apples变量

        apples = 10; // 赋值给外部块的apples

        std::cout << apples << '\n'; // 打印外围的 apples 的值
    } // 外围代码块中的 apples在内层代码块结束时仍然存在

    std::cout << apples << '\n'; // 打印外围代码块中的 apples 变量

    return 0;
} // 外围代码块中的apples被销毁
```

上述程序打印：

```C++
5
10
10
```

### 2、遮挡全局变量

类似于嵌套块中的变量会隐藏外部块中的同名变量，与全局变量同名的局部变量将遮挡全局变量，无论局部变量在作用域中的何处：

```c++
#include <iostream>
int value { 5 }; // 全局变量

void foo()
{
    std::cout << "global variable value: " << value << '\n'; // 这里使用的是全局变量
}

int main()
{
    int value { 7 }; // 会遮挡全局变量 value，直到本代码块结束

    ++value; // 局部变量value加一

    std::cout << "local variable value: " << value << '\n';

    foo();

    return 0;
} // 局部变量 value 销毁
```

此代码打印：

```C++
local variable value: 8
global variable value: 5
```

然而，由于全局变量是全局命名空间的一部分，我们可以使用没有前缀的域操作符（ :: ）来告诉编译器我们是指全局变量，而不是局部变量。

```c++
#include <iostream>
int value { 5 }; // 全局变量

int main()
{
    int value { 7 }; // 会遮挡全局变量 value，直到本代码块结束
    ++value; // 局部变量value加一

    --(::value); // 全局变量 value 减一， 这里的括号是为了可读性

    std::cout << "local variable value: " << value << '\n';
    std::cout << "global variable value: " << ::value << '\n';

    return 0;
} // 局部变量 value 销毁
```

此代码打印：

```C++
local variable value: 8
global variable value: 4
```

> [!important]
>
> 通常应避免局部变量的命名遮挡，因为在使用或修改错误的变量时，会导致意外错误。当变量被遮挡时，某些编译器将发出警告。
>
> 出于相同原因，我们建议也避免遮挡全局变量。如果所有全局变量名称都使用“g_”前缀，则这可以方便的避免。

## 7.5 内部链接

> [!tip]
>
> **全局变量和函数标识符可以具有内部链接或外部链接属性。**
>
> 具有内部链接的标识符可以在单个翻译单元内看到并使用，但它不能从其他翻译单元访问（即，它不向链接器公开）。这意味着，如果两个源文件具有具有内部链接的同名标识符，则这些标识符将被视为独立的（并且不会因具有重复定义而导致ODR冲突）。

### **1、具有内部链接的全局变量**

具有内部链接的全局变量有时称为内部变量。

**为了使非常量的全局变量成为内部变量，使用static关键字。**

```C++
#include <iostream>

static int g_x{}; // 非常量的全局变量默认是外部链接, 但可以通过 static 关键字使它成为内部链接

const int g_y{ 1 }; // const 全局变量默认是内部链接
constexpr int g_z{ 2 }; // constexpr 全局变量默认是内部链接

int main()
{
    std::cout << g_x << ' ' << g_y << ' ' << g_z << '\n';
    return 0;
}
```

:tipping_hand_man:**默认情况下，Const和constexpr全局变量具有内部链接属性（因此不需要static关键字——如果使用static关键字也无额外作用）。**

下面是使用内部变量的多个文件的示例：

a.cpp

```
constexpr int g_x { 2 }; // 这里的内部链接 g_x 只在 a.cpp 中能被访问 
```

main.cpp：

```C++
#include <iostream>

static int g_x { 3 }; // 这里的内部链接 g_x is 只在main.cpp 中能被访问

int main()
{
    std::cout << g_x << '\n'; // 使用 main.cpp 中的 g_x, 打印 3

    return 0;
}
```

该程序打印：

```
3
```

因为g_x是每个文件的内部变量，所以main.cpp不知道a.cpp也有一个名为g_x的变量（反之亦然）。

### 2、具有内部链接的函数

由于链接是标识符的属性（不是变量的属性），函数标识符也具有链接属性。函数默认为外部链接，但可以通过static关键字设置为内部链接：

add.cpp：

```C++
// 这个函数被声明为 static, 因此只能在本文件中被使用
// 即是其它文件中有add函数的前向声明，但也仍然不能访问到add函数
static int add(int x, int y)
{
    return x + y;
}
```

main.cpp：

```C++
#include <iostream>

static int add(int x, int y); // 前向声明 add

int main()
{
    std::cout << add(3, 4) << '\n';

    return 0;
}
```

此程序无法链接成功，因为在add.cpp之外无法访问函数add。

> [!Note]
>
> **为什么要费心为标识符提供内部链接？**
>
> 让标识符具有内部链接通常有两个原因：
>
> 1. 有一个标识符，我们要确保其他文件无法访问。这可能是一个我们不想弄乱的全局变量，或者是一个不想调用的辅助函数。
> 2. 避免命名冲突。由于具有内部链接的标识符不会向链接器公开，因此它们只能与同一翻译单元中的名称发生冲突，而不会在整个程序中发生冲突。
>
> **当您有明确的理由不允许从其他文件访问时，将标识符设置为内部链接。**
>
> **最好将您不希望其他文件访问的所有标识符设置为内部链接（使用未命名的命名空间）。**

## 7.6 外部链接

> [!tip]
>
> 具有外部链接的标识符既可以从定义它的文件中看到，也可以从其他代码文件中使用（通过前向声明）。在这种意义上，具有外部链接的标识符是真正的“全局”标识符，因为它们可以在程序中的任何位置使用！

### 1、默认情况下，函数具有外部链接

在前面多个代码文件的程序中，可以从一个文件调用在另一个文件中定义的函数。这是因为函数在默认情况下具有外部链接。

为了调用在另一个文件中定义的函数，必须在使用该函数的任何其他文件中放置该函数的前向声明。前向声明将函数的存在告知编译器，链接器将函数调用连接到实际的函数定义。

下面是一个示例：

a.cpp：

```C++
#include <iostream>

void sayHi() // 这个函数有外部链接，其它文件中可以使用
{
    std::cout << "Hi!\n";
}
```

main.cpp：

```C++
void sayHi(); // 函数 sayHi 的前向声明, 让 sayHi 可以在这个文件中使用

int main()
{
    sayHi(); // 调用其它文件中定义的函数, 链接器会连接到实际的函数定义

    return 0;
}
```

上述程序打印：

```
Hi!
```

在上面的示例中，main.cpp中函数 sayHi() 的前向声明，允许main.cpp访问在a.cpp.中定义的 sayHi() 函数。前向声明满足了编译器的要求，并且链接器能够将函数调用链接到函数定义。

如果函数 sayHi() 具有内部链接，则链接器将无法将函数调用连接到函数定义，并将导致链接错误。

### 2、具有外部链接的全局变量

具有外部链接的全局变量有时称为外部变量。要将全局变量设置为外部变量（因此可由其他文件访问），可以使用extern关键字执行此操作：

```C++
int g_x { 2 }; // 非常量全局变量默认是 外部链接

extern const int g_y { 3 }; // const 全局变量可以使用extern, 设置为外部链接
extern constexpr int g_z { 3 }; // constexpr 全局变量可以使用extern, 设置为外部链接 (但这是无用的定义, 详情见下述内容)

int main()
{
    return 0;
}
```

> [!important]
>
> 默认情况下，非常量的全局变量是外部链接（添加extern关键字也会被忽略）。

### 3、通过extern关键字进行变量前向声明

要实际使用在另一个文件中定义的外部全局变量，还必须在希望使用该变量的任何其他文件中放置全局变量的前向声明。对于变量，也可以通过extern关键字（没有初始化值）创建前向声明。

下面是使用变量前向声明的示例：

a.cpp：

```C++
// 全局变量定义
int g_x { 2 }; // 非常量全局变量默认是 外部链接
extern const int g_y { 3 }; // const 全局变量可以使用extern, 设置为外部链接
```

main.cpp：

```C++
#include <iostream>

extern int g_x; // 这里的extern，表示 g_x 是在其它地方定义的全局变量，这里做一个前向声明
extern const int g_y; // 这里的extern，表示 g_x 是在其它地方定义的 const 全局变量，这里做一个前向声明

int main()
{
    std::cout << g_x << ' ' << g_y << '\n'; // 打印 2 3

    return 0;
}
```

在上面的示例中，a.cpp和main.cpp都引用了名为g_x的相同全局变量。因此，即使g_x是在a.cpp中定义和初始化的，我们也可以通过g_x的前向声明在main.cpp内使用它的值。

:tipping_hand_man:**请注意，extern关键字在不同的上下文中具有不同的含义。在某些上下文中，extern意味着“为该变量提供外部链接”。在其他上下文中，extern意味着“这是在其他地方定义的外部变量的前向声明”。是的，这很令人困惑，因此我们在后续课程中总结了所有这些用法——作用域、存储期和链接。**

> [!warning]
>
> **警告**
>
> 如果要定义未初始化的非常量全局变量，请不要使用extern关键字，否则C++会认为您正在尝试对该变量进行前向声明。

## 7.7 为什么（非常量）全局变量是邪恶的






