# 第七章 作用域与编译链接

## 7.1 自定义命名空间

在之前，我们介绍了命名冲突和命名空间的概念。提醒一下，当两个相同的标识符被引入同一作用域时，就会发生命名冲突，编译器无法决定使用哪个标识符。当这种情况发生时，编译器或链接器将产生错误，因为它们没有足够的信息来解决歧义。

> [!tip]
>
> 随着程序变得越来愈大，标识符的数量增加，这反过来导致发生命名冲突的概率显著增加。由于给定范围中的每个名称都可能与同一范围中的其他名称发生潜在冲突，因此标识符的线性增加将导致潜在冲突的指数增加！这是在尽可能小的范围内定义标识符的关键原因之一。

让我们重新查看命名冲突的示例，然后展示如何使用名称空间来改进。在下面的示例中，foo.cpp 和 goo.cpp 是包含执行不同操作但具有相同名称和参数的函数的源文件。

**foo.cpp:**

```cpp
// 这个 doSomething() 将参数相加
int doSomething(int x, int y)
{
    return x + y;
}
```

**goo.cpp:**

```c++
// 这个 doSomething() 将参数相减
int doSomething(int x, int y)
{
    return x - y;
}
```

**main.cpp：**

```c++
#include <iostream>

int doSomething(int x, int y); // 前向声明 doSomething

int main()
{
    std::cout << doSomething(4, 3) << '\n'; // 实际调用的是哪个 doSomething ?
    return 0;
}
```

如果该项目仅包含 foo.cpp 或 goo.cpp 之一（但不同时包含两者），则它将编译通过并运行，而不会发生意外。然而，将两者编译到同一个程序中，会将两个具有相同名称和参数的不同函数引入到同一作用域（全局作用域）中，这会导致命名冲突。因此，链接器将提示错误：

```
goo.cpp:3: multiple definition of `doSomething(int, int)'; foo.cpp:3: first defined here 
```

:tipping_hand_man:**请注意，此错误发生是因为重复定义，因此函数 doSomething 是否被调用并不重要**。

解决此问题的一种方法是重命名其中一个函数，以便名称不再冲突。但这也需要更改所有函数被调用的位置，很麻烦，并且容易出错。避免冲突的更好方法是将函数放入自己的命名空间中。基于这个原因，标准库被移动到 std 命名空间中。

## 7.2 局部变量

> [!tip]
>
> **局部变量是在函数内定义的变量（包括函数参数）。**

在之前，我们还介绍了作用域的概念。标识符的作用域确定了可以在源代码中访问标识符的作用域。当一个标识符可以被访问时，我们说它在作用域内。当标识符不能被访问时，我们说它超出作用域。作用域是编译时属性，当标识符超出作用域时，尝试使用它将导致编译错误。

### **1、局部变量具有代码块作用域**

局部变量具有代码块作用域，这意味着从定义点到定义它们的代码块的末尾都在作用域内。

```c++
int main()
{
    int i { 5 }; // i 进入作用域
    double d { 4.0 }; // d 进入作用域

    return 0;
} // d 和 i 离开作用域
```

尽管函数参数没有在函数体内定义，但对于一般函数，它们可以被视为函数体内作用域的一部分。

```c++
int max(int x, int y) // x 和 y 进入作用域
{
    // 将x与y的最大值赋值给max
    int max{ (x > y) ? x : y }; // max 进入作用域

    return max;
} // max, y, x 离开作用域
```

### **2、作用域内的所有变量名都必须唯一**

变量名在给定作用域内必须唯一。考虑以下程序：

```C++
void someFunction(int x)
{
    int x{}; // 编译失败，x与参数名称冲突
}

int main()
{
    return 0;
}
```

### **3、局部变量具有自动存储期**

变量的存储期（storage duration）规则，决定了何时以及如何创建和销毁变量。在大多数情况下，变量的存储期规则直接决定其生命周期。

例如，局部变量具有自动存储期，这意味着它们在定义点创建，在定义它们的代码块末尾销毁。例如：

```c++
int main()
{
    int i { 5 }; // i 创建与初始化
    double d { 4.0 }; // d 创建与初始化

    return 0;
} // d i 在这里被销毁
```

### **4、嵌套代码块中的局部变量**

局部变量可以在嵌套块内定义。这与函数体块中的局部变量相同：

```
int main() // 外围代码块
{
    int x { 5 }; // x 进入作用域，并被创建

    { // 内层代码块
        int y { 7 }; // y 进入作用域，并被创建
    } // y 离开作用域，并被销毁

    // y 无法再被使用，因为离开了作用域

    return 0;
} // x 离开作用域，并被销毁
```

在上面的示例中，变量 y 在嵌套代码块中定义。它的作用域从定义点到嵌套块的末尾，并且其生命周期也相同。因为变量 y 的作用域限制在定义它的内部块中，所以它在外部块不可访问。

**5、变量应在最有限的作用域内定义**

如果变量仅在嵌套块中使用，则应在该嵌套块中定义：

```c++
#include <iostream>

int main()
{
    // 不要在这里定义y

    {
        // y 只在这个代码块内使用，所以在这里定义
        int y { 5 };
        std::cout << y << '\n';
    }

    // 后续不再使用y，所以没有必要能够看到y的定义

    return 0;
}
```

## 7.3 全局变量

> [!tip]
>
> 在 C++中，变量也可以在函数外部声明。这样的变量称为全局变量。

### **1、声明全局变量**

按照惯例，全局变量在全局命名空间中的文件顶部、include 的下方声明。下面是示例：

```c++
#include <iostream>

// 函数外的变量是全局变量
int g_x {}; // 全局变量 g_x

void doSomething()
{
    // 全局变量声明后，可以在文件内的任意位置看到和使用
    g_x = 3;
    std::cout << g_x << '\n';
}

int main()
{
    doSomething();
    std::cout << g_x << '\n';

    // 全局变量声明后，可以在文件内的任意位置看到和使用
    g_x = 5;
    std::cout << g_x << '\n';

    return 0;
}
// 文件结束，g_x离开作用域
```

### **2、全局变量的作用域**

> [!tip]
>
> 在全局名空间中声明的标识符具有全局命名空间作用域（通常称为全局作用域，有时非正式地称为文件作用域），这意味着它们从声明点到声明它们的文件末尾都是可见的。

一旦声明，全局变量就可以在文件中的任何位置使用！在上面的示例中，函数 doSomething() 和 main() 中都使用了全局变量 g_x。

全局变量也可以在用户定义的命名空间内定义。下面是与上面相同的示例，但 g_x 已从全局范围移动到用户定义的命名空间 Foo：

```
#include <iostream>

namespace Foo // Foo 在全局命名空间中定义
{
    int g_x {}; // g_x 现在位于 Foo 命名空间中, 但仍是全局变量
}

void doSomething()
{
    // 全局变量声明后，可以在文件内的任意位置看到和使用
    Foo::g_x = 3;
    std::cout << Foo::g_x << '\n';
}

int main()
{
    doSomething();
    std::cout << Foo::g_x << '\n';

    // 全局变量声明后，可以在文件内的任意位置看到和使用
    Foo::g_x = 5;
    std::cout << Foo::g_x << '\n';

    return 0;
}
```

:bulb: **尽管上面的代码中标识符 g_x 现在被限制在命名空间 Foo，但该名称仍然可以全局访问（通过 Foo:: g_x），g_x 仍然是全局变量。**

> [!Note]
>
> 在命名空间内声明的变量也是全局变量。

### **3、全局变量具有静态存储期**

全局变量在程序启动时创建，在程序结束时销毁。这称为静态存储期。具有静态存储期的变量有时称为静态变量。

 **命名全局变量**

按照惯例，一些开发人员在非常量的全局变量标识符前面加上“g”或“g_”，以表示它们是全局的。该前缀有几种用途：

1. 它有助于避免与全局命名空间中的其他标识符发生命名冲突。
2. 它有助于防止无意中的命名遮挡（name shadowing）（后续讨论）。
3. 它有助于指示变量存在于函数范围之外，因此，对它们所做的任何更改也将持续存在。

> [!Important]
>
> 在命名非常量的全局变量时，请考虑使用“g”或“g_”前缀，以帮助将它们与局部变量和函数参数区分开来。

**全局变量初始化**

与局部变量（默认情况下未初始化）不同，具有静态存储期的变量默认为被零初始化。

也可以选择初始化非常量的全局变量：

```
int g_x; //未显示初始化
int g_y{}; //值初始化
int g_z{1}; //使用值初始化
```

## **7.4 变量名称遮挡**

> [!tip]
>
> 每个代码块有自己的变量命名的空间。那么，当我们在嵌套的内部块中有一个变量，该变量与外部块中的变量同名时，会发生什么呢？当这种情况发生时，嵌套块内的变量会“遮挡”外部变量。

### 1、局部变量名称遮挡

```c++
#include <iostream>

int main()
{ // 外围代码块
    int apples { 5 }; // 外围代码块中的 apples 变量

    { // 内层代码块
        // 这里的 apples 是外围的
        std::cout << apples << '\n'; // 打印外围的 apples 的值

        int apples{ 0 }; // 嵌套的代码块中的 apples 变量

        // apples 现在指代的是内层代码块里的变量
        // 外围的被遮挡住了

        apples = 10; // 内层的 apples 被赋值

        std::cout << apples << '\n'; // 打印内层的 apples的值
    } // 内层代码块中的apples被销毁


    std::cout << apples << '\n'; // 打印外围代码块中的 apples 变量

    return 0;
} // 外围代码块中的apples被销毁
```

如果运行此程序，它将打印：

```C++
5
10
5
```

在上面的程序中，我们首先在外部块中声明一个名为 apples 的变量。该变量在内部块中可见，我们可以通过打印其值（5）来查看。然后，我们在嵌套块中声明一个不同的变量（也称为 apples）。从这一位置到块的末尾，名称 apples 是指嵌套块内的变量，而不是外部块。

因此，当我们将值 10 分配给 apples 时，我们将其分配给嵌套块内的 apples。打印该值（10）后，嵌套块结束，嵌套块 apples 被销毁。外围块 apples 的存在和值不受影响，我们通过打印 apples（5）的值来证明这一点。

:tipping_hand_man:==**请注意，如果未在嵌套块内新定义 apples，则嵌套块中的 apples 仍然指外部块 apples，因此将值 10 分配给 apples 将应用于外部块 apples：**==

```c++
#include <iostream>

int main()
{ // 外围代码块
    int apples{5}; // 外围代码块中的 apples 变量

    { // 内层代码块
        // apples refers to outer block apples here
        std::cout << apples << '\n'; // 打印外围的 apples 的值

        // 这个例子不定义内层的apples变量

        apples = 10; // 赋值给外部块的apples

        std::cout << apples << '\n'; // 打印外围的 apples 的值
    } // 外围代码块中的 apples在内层代码块结束时仍然存在

    std::cout << apples << '\n'; // 打印外围代码块中的 apples 变量

    return 0;
} // 外围代码块中的apples被销毁
```

上述程序打印：

```C++
5
10
10
```

### 2、遮挡全局变量

类似于嵌套块中的变量会隐藏外部块中的同名变量，与全局变量同名的局部变量将遮挡全局变量，无论局部变量在作用域中的何处：

```c++
#include <iostream>
int value { 5 }; // 全局变量

void foo()
{
    std::cout << "global variable value: " << value << '\n'; // 这里使用的是全局变量
}

int main()
{
    int value { 7 }; // 会遮挡全局变量 value，直到本代码块结束

    ++value; // 局部变量value加一

    std::cout << "local variable value: " << value << '\n';

    foo();

    return 0;
} // 局部变量 value 销毁
```

此代码打印：

```C++
local variable value: 8
global variable value: 5
```

然而，由于全局变量是全局命名空间的一部分，我们可以使用没有前缀的域操作符（ :: ）来告诉编译器我们是指全局变量，而不是局部变量。

```c++
#include <iostream>
int value { 5 }; // 全局变量

int main()
{
    int value { 7 }; // 会遮挡全局变量 value，直到本代码块结束
    ++value; // 局部变量value加一

    --(::value); // 全局变量 value 减一， 这里的括号是为了可读性

    std::cout << "local variable value: " << value << '\n';
    std::cout << "global variable value: " << ::value << '\n';

    return 0;
} // 局部变量 value 销毁
```

此代码打印：

```C++
local variable value: 8
global variable value: 4
```

> [!important]
>
> 通常应避免局部变量的命名遮挡，因为在使用或修改错误的变量时，会导致意外错误。当变量被遮挡时，某些编译器将发出警告。
>
> 出于相同原因，我们建议也避免遮挡全局变量。如果所有全局变量名称都使用“g_”前缀，则这可以方便的避免。

## 7.5 内部链接

> [!tip]
>
> **全局变量和函数标识符可以具有内部链接或外部链接属性。**
>
> 具有内部链接的标识符可以在单个翻译单元内看到并使用，但它不能从其他翻译单元访问（即，它不向链接器公开）。这意味着，如果两个源文件具有具有内部链接的同名标识符，则这些标识符将被视为独立的（并且不会因具有重复定义而导致 ODR 冲突）。

### **1、具有内部链接的全局变量**

具有内部链接的全局变量有时称为内部变量。

**为了使非常量的全局变量成为内部变量，使用 static 关键字。**

```C++
#include <iostream>

static int g_x{}; // 非常量的全局变量默认是外部链接, 但可以通过 static 关键字使它成为内部链接

const int g_y{ 1 }; // const 全局变量默认是内部链接
constexpr int g_z{ 2 }; // constexpr 全局变量默认是内部链接

int main()
{
    std::cout << g_x << ' ' << g_y << ' ' << g_z << '\n';
    return 0;
}
```

:tipping_hand_man:**默认情况下，Const 和 constexpr 全局变量具有内部链接属性（因此不需要 static 关键字——如果使用 static 关键字也无额外作用）。**

下面是使用内部变量的多个文件的示例：

a.cpp

```
constexpr int g_x { 2 }; // 这里的内部链接 g_x 只在 a.cpp 中能被访问 
```

main.cpp：

```C++
#include <iostream>

static int g_x { 3 }; // 这里的内部链接 g_x is 只在main.cpp 中能被访问

int main()
{
    std::cout << g_x << '\n'; // 使用 main.cpp 中的 g_x, 打印 3

    return 0;
}
```

该程序打印：

```
3
```

因为 g_x 是每个文件的内部变量，所以 main.cpp 不知道 a.cpp 也有一个名为 g_x 的变量（反之亦然）。

### 2、具有内部链接的函数

由于链接是标识符的属性（不是变量的属性），函数标识符也具有链接属性。函数默认为外部链接，但可以通过 static 关键字设置为内部链接：

add.cpp：

```C++
// 这个函数被声明为 static, 因此只能在本文件中被使用
// 即是其它文件中有add函数的前向声明，但也仍然不能访问到add函数
static int add(int x, int y)
{
    return x + y;
}
```

main.cpp：

```C++
#include <iostream>

static int add(int x, int y); // 前向声明 add

int main()
{
    std::cout << add(3, 4) << '\n';

    return 0;
}
```

此程序无法链接成功，因为在 add.cpp 之外无法访问函数 add。

> [!Note]
>
> **为什么要费心为标识符提供内部链接？**
>
> 让标识符具有内部链接通常有两个原因：
>
> 1. 有一个标识符，我们要确保其他文件无法访问。这可能是一个我们不想弄乱的全局变量，或者是一个不想调用的辅助函数。
> 2. 避免命名冲突。由于具有内部链接的标识符不会向链接器公开，因此它们只能与同一翻译单元中的名称发生冲突，而不会在整个程序中发生冲突。
>
> **当您有明确的理由不允许从其他文件访问时，将标识符设置为内部链接。**
>
> **最好将您不希望其他文件访问的所有标识符设置为内部链接（使用未命名的命名空间）。**

## 7.6 外部链接

> [!tip]
>
> 具有外部链接的标识符既可以从定义它的文件中看到，也可以从其他代码文件中使用（通过前向声明）。在这种意义上，具有外部链接的标识符是真正的“全局”标识符，因为它们可以在程序中的任何位置使用！

### 1、默认情况下，函数具有外部链接

在前面多个代码文件的程序中，可以从一个文件调用在另一个文件中定义的函数。这是因为函数在默认情况下具有外部链接。

为了调用在另一个文件中定义的函数，必须在使用该函数的任何其他文件中放置该函数的前向声明。前向声明将函数的存在告知编译器，链接器将函数调用连接到实际的函数定义。

下面是一个示例：

a.cpp：

```C++
#include <iostream>

void sayHi() // 这个函数有外部链接，其它文件中可以使用
{
    std::cout << "Hi!\n";
}
```

main.cpp：

```C++
void sayHi(); // 函数 sayHi 的前向声明, 让 sayHi 可以在这个文件中使用

int main()
{
    sayHi(); // 调用其它文件中定义的函数, 链接器会连接到实际的函数定义

    return 0;
}
```

上述程序打印：

```
Hi!
```

在上面的示例中，main.cpp 中函数 sayHi() 的前向声明，允许 main.cpp 访问在 a.cpp.中定义的 sayHi() 函数。前向声明满足了编译器的要求，并且链接器能够将函数调用链接到函数定义。

如果函数 sayHi() 具有内部链接，则链接器将无法将函数调用连接到函数定义，并将导致链接错误。

### 2、具有外部链接的全局变量

具有外部链接的全局变量有时称为外部变量。要将全局变量设置为外部变量（因此可由其他文件访问），可以使用 extern 关键字执行此操作：

```C++
int g_x { 2 }; // 非常量全局变量默认是 外部链接

extern const int g_y { 3 }; // const 全局变量可以使用extern, 设置为外部链接
extern constexpr int g_z { 3 }; // constexpr 全局变量可以使用extern, 设置为外部链接 (但这是无用的定义, 详情见下述内容)

int main()
{
    return 0;
}
```

> [!important]
>
> 默认情况下，非常量的全局变量是外部链接（添加 extern 关键字也会被忽略）。

### 3、通过 extern 关键字进行变量前向声明

要实际使用在另一个文件中定义的外部全局变量，还必须在希望使用该变量的任何其他文件中放置全局变量的前向声明。对于变量，也可以通过 extern 关键字（没有初始化值）创建前向声明。

下面是使用变量前向声明的示例：

a.cpp：

```C++
// 全局变量定义
int g_x { 2 }; // 非常量全局变量默认是 外部链接
extern const int g_y { 3 }; // const 全局变量可以使用extern, 设置为外部链接
```

main.cpp：

```C++
#include <iostream>

extern int g_x; // 这里的extern，表示 g_x 是在其它地方定义的全局变量，这里做一个前向声明
extern const int g_y; // 这里的extern，表示 g_x 是在其它地方定义的 const 全局变量，这里做一个前向声明

int main()
{
    std::cout << g_x << ' ' << g_y << '\n'; // 打印 2 3

    return 0;
}
```

在上面的示例中，a.cpp 和 main.cpp 都引用了名为 g_x 的相同全局变量。因此，即使 g_x 是在 a.cpp 中定义和初始化的，我们也可以通过 g_x 的前向声明在 main.cpp 内使用它的值。

:tipping_hand_man:**请注意，extern 关键字在不同的上下文中具有不同的含义。在某些上下文中，extern 意味着“为该变量提供外部链接”。在其他上下文中，extern 意味着“这是在其他地方定义的外部变量的前向声明”。是的，这很令人困惑，因此我们在后续课程中总结了所有这些用法——作用域、存储期和链接。**

> [!warning]
>
> **警告**
>
> 如果要定义未初始化的非常量全局变量，请不要使用 extern 关键字，否则 C++会认为您正在尝试对该变量进行前向声明。

## 7.7 为什么（非常量）全局变量是邪恶的

### 1、为什么（非常量）全局变量是邪恶的

**到目前为止，非常量全局变量是危险的最大原因是，它们的值可以被调用的任何函数更改，并且程序员没有简单的方法得知这发生在哪里。**

>[!tip]
>
>尽可能使用局部变量而不是全局变量。

## 7.8 在多个文件中共享全局常量

在某些应用程序中，可能需要在整个代码中使用某些符号常量（而不仅仅是在一个位置）。例如不改变的物理或数学常数（例如，pi或阿伏伽德罗数），或特定于应用的“系数”值（例如，摩擦系数或重力系数）。与其在每个需要它们的文件中重新定义这些常量），不如在中心位置声明它们一次，并在需要的地方使用它们。这样，如果需要更改它们，只需要在一个地方更改它们，并且这些更改可以传播出去。

### 1、作为内部变量的全局常数

在C++17之前，以下是最简单、最常见的解决方案：

> 1. 创建一个头文件来放置这些值。
> 2. 在创建的头文件中定义一个命名空间。
> 3. 使用constexpr来定义这些变量。
> 4. 使用#include，将这个头文件包含在需要使用它的地方。

例如：

constants.h：

```C++
#ifndef CONSTANTS_H
#define CONSTANTS_H

// 定义你自己的命名空间
namespace constants
{
    // 常量 默认内部链接
    constexpr double pi { 3.14159 };
    constexpr double avogadro { 6.0221413e23 };
    constexpr double myGravity { 9.2 }; // m/s^2 -- 重力在这个星球上稍微轻一点
    // ... 其它定义的常量
}
#endif
```

然后使用域解析操作符（::），左边是命名空间名称，右边是变量名称，来访问常量：

main.cpp：

```C++
#include "constants.h" // 本文件中，将包含每一个常量的定义

#include <iostream>

int main()
{
    std::cout << "Enter a radius: ";
    double radius{};
    std::cin >> radius;

    std::cout << "The circumference is: " << 2 * radius * constants::pi << '\n';

    return 0;
}
```

当该头文件被包含到.cpp文件中时，头文件中定义的每个变量都将被复制到代码文件中。因为这些变量位于函数外部，所以它们被视为包含的文件中的全局变量，然后可以在该文件中的任何位置使用它们。

因为const全局变量具有内部链接，所以每个.cpp文件都获得链接器看不到的全局变量的独立版本。在大多数情况下，由于这些是常量，编译器将简单的优化掉这些变量。

### 2、作为外部链接属性的全局常量

**上述方法有一些潜在的缺点:**

虽然方法很简单（对于较小的程序来说也很好），但每次constants.h被包含在不同的代码文件中时，这些变量每个都会复制到对应的代码文件中。如果constants.h被包含在20个不同的代码文件中，则每个变量都重复20次。头文件保护不会阻止这种情况的发生，因为它们只会防止头文件被多次包含到单个文件中，而不是被一次包含到多个不同的代码文件中。这带来了两个挑战：

> 1. 改变一个常量，需要重编引用到对应头文件的所有代码文件，在大型项目中，会导致较长的重新编译时间。
> 2. 如果常量很大，不能被优化掉，那么会消耗大量的内存。

避免这些问题的一种方法是将这些常量转换为外部变量，因为可以有一个在所有文件中共享的单个变量（初始化一次）。在这种方法中，我们将在.cpp文件中定义常量（以确保定义仅存在于一个位置），并在头中进行声明（它将包含在其他文件中）。

constants.cpp：

```C++
#include "constants.h"

namespace constants
{
    // 实际的常量定义
    extern const double pi { 3.14159 };
    extern const double avogadro { 6.0221413e23 };
    extern const double myGravity { 9.2 }; // m/s^2 -- 重力在这个星球上稍微轻一点
}
```

constants.h：

```C++
#ifndef CONSTANTS_H
#define CONSTANTS_H

namespace constants
{
    // 因为定义是存在于命名空间中, 所以前向声明也在对应的命名空间
    extern const double pi;
    extern const double avogadro;
    extern const double myGravity;
}

#endif
```

在代码文件中的使用保持不变：

main.cpp：

```C++
#include "constants.h" // 引入所有的前向声明

#include <iostream>

int main()
{
    std::cout << "Enter a radius: ";
    double radius{};
    std::cin >> radius;

    std::cout << "The circumference is: " << 2 * radius * constants::pi << '\n';

    return 0;
}
```

由于全局符号常量具有名称空间（以避免与全局名称空间中的其他标识符发生命名冲突），因此不需要使用“g_”命名前缀。

现在，符号常量将仅实例化一次（在constants.cpp中），而不是在包含constants.h的每个代码文件中实例化，并且这些常量的所有使用都将链接到constants.cpp，对constants.cpp所做的任何更改都将只需要重新编译constants.cpp。

**然而，这种方法有几个缺点。**

>[!bug]
>
>1、这些常量现在仅在它们实际定义的文件（constants.cpp）中被视为编译时常量。在其他文件中，编译器将只看到前向声明，该声明不定义常量值（并且必须由链接器解析）。这意味着在其他文件中，它们被视为运行时常量值，而不是编译时常量。因此，在constants.cpp之外，不能在需要编译时常量的任何地方使用这些变量。其次，由于编译时常量通常可以比运行时常量更容易优化，编译器可能无法对这些常量进行足够的优化。
>
>2、由于编译器单独编译每个源文件，因此它只能看到出现在正在编译的源文件中的变量定义（包括任何包含的头文件）。例如，当编译器编译main.cpp时，constants.cpp中的变量定义不可见。因此，constexpr变量不能分为头文件和源文件，它们必须在头文件中定义。

鉴于上述缺点，最好在头文件中定义常量。如果您发现常量的值经常变动（例如，因为您正在调整程序），导致编译时间过长，则可以根据需要将有问题的常量移到.cpp文件中。

### 3、全局常量作为内联变量 C++17

在前面内联函数和变量的学习中，我们介绍了内联变量，这些变量可以有多个定义，只要这些定义相同。通过使constexpr变量内联，我们可以在头文件中定义它们，然后将它们包含到需要它们的任何.cpp文件中。这避免了单定义规则冲突和重复变量的缺点。

constants.h：

```C++
#ifndef CONSTANTS_H
#define CONSTANTS_H

// 定义你自己的命名空间
namespace constants
{
    inline constexpr double pi { 3.14159 }; // 注: 内联 的 constexpr
    inline constexpr double avogadro { 6.0221413e23 };
    inline constexpr double myGravity { 9.2 }; // m/s^2 -- 重力在这个星球上稍微轻一点
    // ... 其它定义的常量
}
#endif
```

main.cpp：

```C++
#include "constants.h"
#include <iostream>

int main()
{
    std::cout << "Enter a radius: ";
    double radius{};
    std::cin >> radius;

    std::cout << "The circumference is: " << 2 * radius * constants::pi << '\n';

    return 0;
}
```

**我们可以将 constants.h 包含到任意多的代码文件中，但这些变量将仅实例化一次，并在所有代码文件中共享。**

该方法的缺点是，如果更改任何常量值，则需要重新编译包含常量头文件的每个文件。

> [!tip]
>
> Constexpr函数是隐式内联的，但Constexpr变量不是隐式内联的。

> [!note]
>
> 如果需要全局常量，并且编译器支持C++17，则最好在头文件中定义内联constexpr全局变量。

## 7.9 静态局部变量
