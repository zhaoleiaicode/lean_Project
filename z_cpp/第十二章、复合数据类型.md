# 第十二章、复合数据类型

## 12.1复合数据类型

C++支持复合数据类型。复合数据类型是可以从基本数据类型（或其他复合数据类型）构造的数据类型。每个复合数据类型也有自己的唯一属性。

C++支持以下复合类型：

> 1. 函数
> 2. 数组（Arrays）
> 3. 指针类型：
>    - 对象指针
>    - 函数指针
> 4. 指向成员类型的指针：
>    - 指向成员数据的指针
>    - 指向成员函数的指针
> 5. 引用类型：
>    - 左值引用
>    - 右值引用
> 6. 枚举类型：
>    - 强作用域枚举
>    - 若弱作用域枚举
> 7. 类类型：
>    - struct
>    - class
>    - union

## 12.2 值类别（左值 lvalue 和右值 rvalue）

在讨论第一个复合类型（左值引用）之前，我们将绕道一点，讨论一下左值是什么。

### 1.表达式的属性

为了帮助确定表达式的计算方式和使用位置，C++中的所有表达式都有两个属性：类型和值类别。

### 2.表达式的类型

表达式的类型等效于由表达式计算产生的值、对象或函数的类型。例如：

```C++
int main()
{
    auto v1 { 12 / 4 }; // int / int => int
    auto v2 { 12.0 / 4 }; // double / int => double

    return 0;
}
```

对于v1，编译器将（在编译时）确定具有两个int操作数的除法将产生int结果，因此int是该表达式的类型。通过类型推导，int将用作v1的类型。

对于v2，编译器将（在编译时）确定具有double操作数和int操作数的除法将产生double结果。请记住，算术运算符必须具有匹配类型的操作数，因此在这种情况下，int操作数被转换为double，并执行浮点除法。所以double是这个表达式的类型。

编译器可以使用表达式的类型来确定表达式在给定上下文中是否有效。例如：

```C++
#include <iostream>

void print(int x)
{
    std::cout << x << '\n';
}

int main()
{
    print("foo"); // error: print() 需要一个int参数, 但这里传递了一个string字面值

    return 0;
}
```

在上面的程序中，print(int)函数需要一个int参数。然而，我们传递的表达式的类型（字符串字面值"foo"）不匹配，并且找不到转换方式。因此会产生编译错误。

请注意，表达式的类型必须在编译时可确定（否则类型检查和类型推导将不起作用）——然而，表达式的值可以在编译时（如果表达式是constexpr）或运行时（如果该表达式不是constexpr）确定。

### 3.表达式的值类别

现在考虑以下程序：

```C++
int main()
{
    int x{};

    x = 5; // 有效: 可以将 5 赋值给 x
    5 = x; // error: 不能将 x 的值 赋给 字面值 5

    return 0;
}
```

其中一个赋值语句有效（将值5赋值给变量x），另一个无效（将x的值赋值给字面值5是什么意思？）。**那么编译器如何知道哪些表达式可以合法地出现在赋值语句的两侧呢？**

答案在于表达式的第二个属性：值类别。表达式（或子表达式）的值类别指示表达式是解析为值、函数还是某种类型的对象。

在C++11之前，只有两种可能的值类别：左值和右值。

在C++11中，添加了三个额外的值类别（glvalue、prvalue和xvalue）来支持名为移动语义的新功能。

### 4.左值和右值表达式

C++的表达式化分为三种，**左值（lvalue），纯右值（prvaule),亡值（xvalue)**,一般而言将纯右值与亡值合一起称为右值。**通常左值，右值是是针对表达式的**

> **实际上左值与右值并不是什么新引入概念，以前就有，有的说是来自C语言时在等号左边是是左值，右边是右值，也有的说能取地址的是左值，不能取地址的（放寄存器中值）是右值，也有的说有名字的是左值，没有名字的是右值,但这几种说法都可以轻松被推翻。**

(1).**反第一种**说法：

```
int a = 3; // a是左值，3是右值
int b; // b是左值
// a在等号右边，但a是左值,可以取地址
b = a; 
// "Hello Word"在等号右边，字符串字面量，是左值
const char* pStr = "Hello Word"; 
```

(2)**反第二种**说法，首先右值也可以放内存中的，取地址这点还是有点争议的，看一下代码

```
class TestClassA {
    int m_iSize;
    char* m_pkData;
};
// 注意要求传入的rValue是右值，函数体内右值引用实际是左值
// 所以能对rValue取地址，这点后面第三章节完美转发还会再详细讨论
TestClassA* operator& (TestClassA&& rValue) 
{
    return &rValue;
}

// 本来TestClassA()生成临时变量，是右值，但被“&”操作了。
// 这里我们手动重载了&，所以标准说法是不能用内置&取地址
TestClassA* pkA = &TestClassA(100);
```

（3）**反第三种**说法，看一下代码

```
// 字符串字面量没有名字，是左值，
// 我们可以这样直接原始取地址
&("Hello World");

enum eTestEnum
{
    TE_ZERO = 0,
    TE_ONE,
    TE_TWO,
};
// 下面表达式，TE_TWO是一个枚举项，算是有名字，实际是右值
eTestEnum en1 = TE_TWO;
```



## 12.3 左值的引用

> 在C++中，引用是现有对象的别名。定义引用后，对引用的任何操作都将应用于被引用的对象。

这意味着我们可以使用引用来读取或修改被引用的对象。尽管一开始引用可能看起来很傻、无用或冗余，但在C++中引用无处不在（我们将在几节课中看到这方面的例子）。您还可以创建对函数的引用，尽管这样做的频率较低。

现代C++包含两种类型的引用：左值引用和右值引用。在本章中，我们将讨论左值引用。

### 1.左值引用类型

左值引用（通常只是称为引用，因为在C++11之前只有一种类型的引用）充当现有左值（例如变量）的别名。

要声明左值引用类型，我们在类型声明中使用与号（&）：

```
int //普通类型
int& //int类型对象的左值引用
double& //double类型的左值引用
```

### 2.左值引用变量

对于左值引用类型，我们可以做的事情之一是创建左值引用变量。

要创建左值引用变量，我们只需定义具有左值引用类型的变量：

```
#include <iostream>
int main()
{
	int x {5}; //定义普通变量x。
	int& ref {x}; //ref是int类型的左值引用变量、充当变量x的别名
	std::cout << x << "\n";
    std::cout << ref << "\n";
    
    return 0;
}
```

### 3.通过左值引用修改值

在上面的例子中，展示了可以使用引用来读取被引用对象的值。还可以使用引用来修改被引用对象的值：

```
#include <iostream>

int main()
{
    int x { 5 }; // 普通int变量
    int& ref { x }; // ref 现在是 x 的别名

    std::cout << x << ref << '\n'; // 打印 55

    x = 6; // x 现在值是 6

    std::cout << x << ref << '\n'; // 打印 66

    ref = 7; // 对引用的对象（x）现在值是 7

    std::cout << x << ref << '\n'; // 打印 77

    return 0;
}
```

在上面的示例中，ref是x的别名，因此我们可以通过x或ref更改x的值。

### 4.左值引用的初始化

> 与常量很相似，所有引用都必须初始化。

```
int main()
{
	int& invalidRef; //error;引用必须被初始化
	int x {5};
	int& ref {x}; //ok; 有初始化值
	return 0;
}
```

> 左值引用必须绑定到可修改的左值。

```
#include <iostream>
int main()
{
	int x {5};
	int& ref {x};// ok, 绑定到可以修改的左值
	
	const int y {5};
	
	int& invalidRef { y }; //无效、不能绑定到不可修改的左值
	int& invalidRef2 { 0 }; // 无效: 不能绑定到右值
	return 0;
}
```

### 5.引用无法重置

一旦初始化，C++中的引用就不能重置，这意味着不能将其更改为引用另一个对象。

新的C++程序员通常试图通过使用赋值来为引用提供另一个要引用的变量来重置引用。这将通过编译并运行——但不会像预期的那样运行。考虑以下程序：

```C++
#include <iostream>

int main()
{
    int x { 5 };
    int y { 6 };

    int& ref { x }; // ref 是 x 的别名
    
    ref = y; // 将 6 (y的值) 设置给 x (ref所引用的对象)
    // 上面这一行不会将ref的引用重置为y！

    std::cout << x << '\n'; // 你可能认为这里打印 5

    return 0;
}
```

在表达式中计算引用时，它解析为它引用的对象。因此 ref = y 不会将ref更改为引用y。相反，因为ref是x的别名，表达式的计算就像 x = y 一样——并且由于y的计算结果为值6，所以x被赋值6。

### 6.左值引用的作用域

**引用变量遵循与普通变量相同的作用域：**

```C++
#include <iostream>

int main()
{
    int x { 5 }; // 普通变量
    int& ref { x }; // 变量x的引用

     return 0;
} // x 和 ref 在这里失效
```

### 7.引用和被引用对象具有独立的生命周期

1. 引用可以在其引用的对象之前销毁。
2. 被引用的对象可以在引用之前销毁。

当引用在被引用对象之前被销毁时，被引用对象不会受到影响。

## 12.4 const的左值引用

### 1.常量的左值引用

通过在声明左值引用时使用const关键字，我们告诉左值引用将其引用的对象视为const。这样的引用称为对常量值的左值引用（有时称为常量引用）。

```c++
int main()
{
	const int x {5}; //x 是不可修改的左值
	const int& ref {x}; // ok; ref可以引用到x
	return 0;
}
```

由于对常量的左值引用将它们引用的对象视为常量，因此它们可以用于访问不能修改的常量值：

```
int main()
{
	const int x {5}; //x是不可修改的左值
	const int& ref {x} ; //ref 可以引用到x
	
	std::cout<<ref<<"\n"; //ok 我们可以访问const变量
    ref =6;  //error ,不能通过常量引用修改对象
    return 0;
}
```

### 2.使用可修改的左值初始化对常量的左值引用

对常量的左值引用也可以绑定到可修改的左值。在这种情况下，当通过引用访问时，被引用的对象被视为常量（即使底层对象是非常量）：

```
#include <iostream>

int main()
{
	int x {5};
	const int& ref {x}; //ok ，ref可以引用到x
	
	std：：cout << ref << '\n';
	ref = 7; //error、不能通过常量应用修改值
	x = 6；//ok,x 是可修改的左值
	return 0;
}
```

在上面的程序中，我们将常量引用ref绑定到可修改的左值x。然后，我们可以使用ref访问x，但由于ref是常量，我们不能通过ref修改x的值。然而，我们仍然可以直接修改x的数值（使用标识符x）。

> 尽量使用常量引用，除非您需要修改正被引用的对象。

### 3.通过左值引用传递函数参数

在前面的课程中，我们介绍了左值引用。孤立地说，这些可能并不太有用——当可以使用变量本身时，为什么要创建变量的别名？

在本课中，将最终提供一些关于引用有用的原因。然后从本章后面开始，您将看到引用被经常使用。

首先，回忆一下函数参数传递，其中传递给函数的值被复制到函数的参数中:

```
#include <iostream>

void printValue(int y)
{
	std::cout<<y<<"\n";
}// y 在这里被销毁

int main()
{
	std::string x { "Hello, world!" }; // x 是 std::string
	printValue(x); // x 按值拷贝到 y (复制成本高)
	return 0;
}
```

虽然该程序的行为与我们预期的一样，但它也是低效的。与前一个示例相同，当调用printValue()时，x被复制到printValue()的参数y中。然而，在这个示例中，参数是std::string而不是int，std::string是复制成本很高的类类型。每次调用printValue()时都会生成这个昂贵的副本！

可以做得更好。

### 4.引用传递参数

在调用函数时，避免生成参数的昂贵副本的一种方法是按引用传递参数，而不是按值传递。当使用按引用传递时，我们将函数参数声明为引用类型（或常量引用类型），而不是普通类型。调用函数时，每个引用参数都绑定到适当的实际值。因为引用充当参数的别名，所以不会制作参数的副本。

下面是与上面相同的示例，使用按引用传递而不是按值传递:

```
#include <iostream>
#include <string>

void printValue(std::string& y)
{
	std::cout << y << '\n';
}

int main()
{
	std::string x {"Hello, world!"};
	printValue(x);
	return 0;
}
```

该程序与前一个程序相同，只是参数y的类型已从std::string更改为std::string&（左值引用）。现在，当调用printValue(x)时，左值引用参数y被绑定到x。绑定引用总是代价很小，不需要复制x。因为引用充当被引用对象的别名，所以当printValue()使用引用y时，它访问的是实际的x（而不是x的副本）。

> 通过引用，我们可以将原始对象的别名传递给函数，而无需在每次调用函数时复制它。

### 5.通过引用传递参数允许我们更改参数的值

通过值传递对象时，函数参数接收的是对象的副本。这意味着对参数值的任何更改都将对原始对象的副本而不是其本身进行:

```c++
#include <iostream>

void addOne(int y)
{
	++y;
}

int main()
{
	int x {5};
	std::cout << "value = " << x << '\n';
	addOne(x);
	std::cout << "value = " << x << '\n'; // x 未被修改
	return 0;
}
```

在上面的程序中，由于值参数y是x的副本，因此当我们增加y时，这仅影响y。该程序输出:

```C++
value = 5
value = 5
```

然而，由于引用的行为与被引用的对象相同，因此在使用按引用传递参数时，对引用参数所做的任何更改都将影响原始对象:

```C++
#include <iostream>

void addOne(int& y) // y 被绑定到原始的 x
{
    ++y; // 修改的实际是 x
}

int main()
{
    int x { 5 };

    std::cout << "value = " << x << '\n';

    addOne(x);

    std::cout << "value = " << x << '\n'; // x 被修改了

    return 0;
}
```

该程序输出:

```C++
value = 5
value = 6
```

函数修改传入的参数值的功能可能很有用。假设您编写了一个函数来确定怪物是否成功攻击玩家。如果为true，怪物应该对玩家造成一定程度的伤害。如果通过引用传递玩家对象，则该函数可以直接修改传入的实际玩家对象的血量。如果通过值传递玩家对象，则只能修改玩家对象副本的血量，这没有那么有用。

> **通过传递非常量引用作为参数，允许我们在函数中修改原始对象的值。**

### 6.按引用传递参数只能接受可修改的左值

由于对非常量值的引用只能绑定到可修改的左值（本质上是非常量变量）。在实践中，这大大限制了传递引用作为参数的实用性，因为这意味着我们不能传递常量或字面值。例如:

```C++
#include <iostream>

void printValue(int& y) // y 只能接受可修改的左值
{
    std::cout << y << '\n';
}

int main()
{
    int x { 5 };
    printValue(x); // ok: x 是可修改的左值

    const int z { 5 };
    printValue(z); // error: z 是不可修改的左值

    printValue(5); // error: 5 是右值

    return 0;
}
```

幸运的是，有一种简单的方法可以解决这个问题，我们将在下一课中讨论。同时还将研究何时按值传递与按引用传递。

## 12.7通过常量左值引用传递函数参数

与对非常量的引用（它只能绑定到可修改的左值）不同，对**常量的引用可以绑定到可更改的左值、不可修改的左值和右值**。因此，如果我们使引用参数为const，则它将能够绑定到任何类型的参数:

```
#include <iostream>

void printValue(const int& y)
{
	std::cout << y << '\n';
}

int main()
{
	int x {5};
	printValue(x); //ok x是可修改的左值
	const int z {5};
	printValue(z); //ok、z是不可修改的左值
	printValue(5); // ok: 5 是右值
	
	return 0;
}
```

通过常量引用传递与通过引用传递参数提供相同的好处（避免复制参数），同时还保证函数不能更改被引用的值。

例如，以下代码无法编译，因为ref是常量:

```C++
void addOne(const int& ref)
{
    ++ref; // 不被允许: ref 是 const
}
```

而在大多数情况下，我们不希望函数修改参数的值。

现在，我们可以理解允许常量左值引用绑定到右值的动机:没有该功能，就无法将字面值（或其他右值）传递给使用引用传递的函数！

>**最佳实践**
>
>使用常量引用传递函数参数，而不是通过非常量引用，除非有特定的原因需要这样做（例如，函数需要更改参数的值）。

### 1.混合使用按值传递与按引用传递参数

具有多个参数的函数可以随意指定每个参数是按值传递还是按引用传递。

```
#include <string>
#include <iostream>

void foo(int a,int& b, const std::string& c)
{
	//doSomething()
}

int main()
{
	int x {5};
	const std::string s {"Hello, world!"};
	foo(5,x,s);
	return 0;
}
```

在上面的示例中，第一个参数通过值传递，第二个通过引用传递，第三个通过常量引用传递。

### 2.何时使用（常量）引用传递参数

由于类类型的复制成本可能很高（有时显著如此），因此类类型通常通过常量引用传递，而不是通过值传递，以避免对参数进行昂贵的复制。基本类型的复制成本很低，因此它们通常是通过值传递的。

> 通过值传递的其他常见类型:枚举类型和std::string_view。 要通过（const）引用传递的其他常见类型:std::string、std::array和std::vector。

### 3.传递值与传递引用的成本

并非所有的类类型都需要通过引用传递。你可能想知道为什么我们不通过引用来传递所有内容。在本小节（可选阅读）中，我们讨论了传递值与传递引用的成本，并改进了最佳实践，以确定何时应使用哪方法。

有两个关键点可以帮助我们的理解:

首先，复制对象的成本通常与两个因素成比例:

> 1. 对象的大小。使用更多内存的对象复制需要更多的时间。
> 2. 任何额外的设置成本。一些类类型在实例化时执行额外的设置（例如，打开文件或数据库，或分配一定数量的动态内存来保存可变大小的对象）。每次复制对象时都必须支付这些设置成本。

 另一方面，将引用绑定到对象总是很快的（大约与复制基本类型的速度相同）。

其次，通过引用访问对象比通过普通变量标识符访问对象稍微昂贵一些。使用变量标识符，正在运行的程序可以直接访问到分配给该变量的存储器地址，并直接访问该值。对于引用，通常有一个额外的步骤:程序必须首先访问引用以确定引用的对象，然后才能转到该对象的内存地址并访问值。编译器有时也可以使用通过值传递的对象来优化代码，比使用通过引用传递的对象的代码效率更高。这意味着为访问通过引用传递的对象而生成的代码通常比为通过值传递的对象生成的代码慢。

我们现在可以回答为什么不通过引用传递所有内容的问题:

1. 对于复制成本较低的对象，复制的成本类似于绑定的成本，因此我们倾向于传递值，因此生成的代码将更快。
2. 对于复制成本高昂的对象，复制的成本占主导地位，因此我们倾向于通过（常量）引用来避免复制。

最后一个问题是，我们如何定义“廉价复制”？这里没有绝对的答案，因为这因编译器、用例和架构而异。然而，我们可以制定一个很好的经验法则:如果对象使用2个或更少的内存“字”（一般64位机器上，一个“字”是64比特），并且它没有设置成本，则复制对象的成本很低。

### 4.字符串引用

在现代C++中经常出现的一个问题是:在编写具有字符串参数的函数时，参数的类型应该是const std::string&还是std::string_view？

在大多数情况下，std::string_view是更好的选择，因为它可以有效地处理更广泛的参数类型。

```C++
void doSomething(const std::string&);
void doSomething(std::string_view);   // 优先使用
```

在某些情况下，使用const std::string&参数可能更合适:

> 1. 如果您使用的是C++14或更低版本，则std::string_view不可用。
> 2. 如果函数中，需要将输入参数以c样式字符串或者std::string来调用其它函数，则const std:∶string&可能是更好的选择，因为std::string_view不能保证以null结尾（C样式字符串函数所期望的），并且不能有效地转换回std::string

## 12.8 指针简介

指针是C++从C继承而来的强大特性，也是许多有抱负的C++学习者陷入困境的地方。然而，正如您很快就会看到的，指针并不是什么可怕的东西。

事实上，指针的行为很像左值引用。但在我们进一步解释之前，先做一个简单的开场。

考虑一个普通的变量，如下所示：

```
char x {}; // char 使用1字节内存 
```

简单来说，当执行该定义生成的代码时，会将一块内存分配给该对象。假设变量x被分配了内存地址140。每当我们在表达式或语句中使用变量x时，程序将访问存储在内存地址140的值。

关于变量的好处是，不需要担心分配了什么特定的内存地址，或者需要多少字节来存储对象的值。只需要通过给定的标识符来使用变量，编译器将该名称转换为适当分配的内存地址。编译器负责寻址工作。

引用也是如此：

```C++
int main()
{
    char x {}; // 假设x的内存地址是 140
    char& ref { x }; // ref 是 x 的左值引用 (当与类型一起使用时， & 代表左值引用)

    return 0;
}
```

因为ref充当x的别名，所以每当使用ref时，程序将转到内存地址140来访问该值。同样，编译器负责寻址。

### 1.取地址操作（&）

尽管默认情况下变量使用的内存地址不会向我们公开，但确实可以访问到这些信息。运算符（&）返回其操作数的内存地址。这非常简单：

```C++
#include <iostream>

int main()
{
    int x{ 5 };
    std::cout << x << '\n';  // 打印变量 x 的值
    std::cout << &x << '\n'; // 打印变量 x 的地址

    return 0;
}
```

在作者的机器上，上述程序打印：

```C++
5
0027FEA0
```

在上面的示例中，我们使用操作符（&）来获取分配给x的内存地址，并将该地址打印到控制台。内存地址通常打印为十六进制值，通常没有0x前缀。

对于使用多个字节内存的对象，& 操作符将返回该对象使用的第一个字节的内存地址。

>提示
>
>&符号往往会引起混淆，因为它根据上下文具有不同的含义：
>
>1. 当跟在类型名称后面时，& 表示左值引用：int& ref。
>2. 在表达式中的一元上下文中使用时，& 是取地址操作：std::cout « &x。
>3. 在表达式的二进制上下文中使用时，& 是逐位AND运算符：std::cout « x & y。

### 2.解引用运算符（*）

我们可以对地址做的最有用的事情是访问存储在该地址的值。解引用运算符（*）将给定内存地址处的值作为左值返回：

```
#include <iostream>
int main()
{
	int x {5};
	std::cout  << x << "\n";
	std::cout << &x << "\n";
	
	std::cout << *(&x) << "\n";
}
```

上述程序打印：

```C++
5
0027FEA0
5
```

>**关键点**
>
>给定一个内存地址，我们可以使用解引用操作符（*）来获取该地址的值（作为左值）。
>
>运算符（&）和解引用运算符（*）是相反的：& 获取对象的地址，而解引用获取地址处的对象。

**尽管解引用运算符看起来就像乘法运算符，但可以区分它们，因为解引用运算符是一元的，而乘法运算符是二元的。**

获取变量的内存地址，然后立即解引用该地址以获取值也不是那么有用（毕竟，我们可以只使用变量来访问值）。

**但现在我们已经在工具包中添加了操作符（&）和解引用操作符（*），可以准备好讨论指针了。**

### 2.指针（pointer）

指针是保存内存地址（通常是另一个变量的地址）作为其值的对象。这允许我们存储其他对象的地址以供以后使用。

与使用与号（&）字符声明引用类型很相似，指针类型使用星号（*）声明：

```
int； //普通的int
int& ; //int的左值引用

int* ；//指向int的指针(保存对应的内存地址值)
```

要创建指针变量，我们只需定义具有指针类型的变量：

```
int main()
{
	int x {5};
	int& ref {x}; //int引用、绑定到x
	
	int* ptr; //指向int的指针
	return 0;
}
```

### 3.指针初始化

与普通变量一样，指针在默认情况下不会初始化。尚未初始化的指针有时称为野指针。野指针包含垃圾地址，解引用野指针将导致未定义的行为。因此，您应该始终初始化指针。

```
int main()
{
	int x {5};
	
	int* ptr; //定义int类型的指针
	int* ptr2{}; //空指针
	int* ptr3{ &x }; //指针。指向x地址的指针
	
	return 0;
}
```

由于指针保存地址，因此当我们初始化指针或将值赋给指针时，该值必须是地址。通常，指针用于保存另一个变量的地址（可以使用操作符（&）的地址来获得）。

一旦有一个指针保存另一个对象的地址，就可以使用解引用操作符（*）来访问该地址上的值。例如：

```
int main()
{
	int x {5};
	std::cout << x << "\n"; //打印变量x的值
	
	int* ptr {&x}; //ptr保存x的地址
	std::cout << *ptr << "\n"; //使用解引用获取ptr地址的值
	
	return 0;
}
```

就像引用的类型必须匹配被引用对象的类型一样，指针的类型必须与所指向的对象的类型匹配：

```
int main()
{
	int i {5};
	double d {7.0};
	
	int* iPtr{ &i }; //ok int类型指针、指向int
	int* iPtr2 {&d}; // error、 int类型指针不能指向double
	double* dPtr{ &d };  // ok: double指针，指向double
	double* dPtr2{ &i }; // not okay: double指针不能指向int
	
	return 0;
}
```

### 4.指针和赋值

我们可以以两种不同的赋值方式来使用指针：

> 1. 改变指针所指向的对象（为指针赋值一个新的所指向的地址）
> 2. 改变指针指向对象的值（通过解引用操作，为所指对象赋值）

首先，让我们来看一个指针更改为指向其他对象的情况：

```
int main()
{
	int x{5};
	int* ptr{&x}; //ptr初始化指向x
	
	std::cout << *ptr << "\n"; //打印指向x
	
	int y {6};
	ptr = &y; //将ptr指向y
	
	std::cout << *ptr << "\n"; //打印指向ptr的值y值
	
	return 0;
}
```

我们定义了指针ptr，用x的地址初始化它，并解引用指针以打印指向的值（5）。然后，我们使用赋值运算符将ptr保存的地址更改为y的地址。然后，再次解引用指针，以打印所指向的值（现在是6）。

如何使用指针来更改所指向的值：

```c++
#include <iostream>

int main()
{
	int x{5};
	int* ptr{ &x };
	
	std::cout << x << "\n";
	std::cout << *ptr << "\n";
	
	*ptr = 6;
	
	std::cout << x << "\n";
	std::cout << *ptr << "\n";
	return 0;
}
```

> 当使用没有解引用（ptr）的指针时，访问指针持有的地址。修改它（ptr=&y）将更改指针所指向的地址。
>
> 当解引用指针（*ptr）时，访问所指向的对象。修改它（*ptr=6；）将更改所指向对象的值。

指针和左值引用的行为类似。

```
#include <iostream>

int main()
{
	int x {5};
	int& ref {x}; //red是x的别名
	int* ptr {&x}; //ptr指向x
	
	std::cout << x;
	std::cout << ref
	std::cout << *ptr << "\n";
	
	ref =6 ; //使用引用修改x
	std::cout << x;
	std::cout << ref
	std::cout << *ptr << "\n";
	
	*ptr = 7; //使用指针修改x
    std::cout << x;
    std::cout << ref;  // 使用引用打印 x 的值 (7)
    std::cout << *ptr << '\n'; // 使用指针打印 x 的值 (7)	
	return 0;
}
```

### 5.取址操作返回的是指针

值得注意的是，操作符（&）不会以文本形式返回其操作数的地址。相反，它返回一个指针，该指针包含操作数的地址，其类型是从参数派生的（例如，获取int的地址将返回int指针中的地址）。

我们可以在下面的示例中看到这一点：

```
#include <iostream>
#include <typeinfo>

int main()
{
	int x {4};
	std::cout << typeid(&x).name() << '\n';
	return 0;
}
```

打印结果:

```
int *
```

>指针是保存内存地址的变量。可以使用解引用操作符（*）来解引用它们，以检索它们所持有的地址处的值。解引用野指针或悬空指针将导致未定义的行为，并可能导致应用程序崩溃。

### 6.空指针

除了实际内存地址，指针还可以保存一个特定的值：空值。空值（通常缩写为null）是一个特殊的值，表示某物没有值。当指针持有空值时，这意味着指针没有指向任何东西。这样的指针称为空指针。

创建空指针的最简单方法是使用值初始化：

```
int main()
{
	int* ptr {}; //ptr是空指针，不指定任何对象
	return 0;
}
```

因为我们可以使用赋值来更改指针指向的内容，所以最初设置为null的指针稍后可以更改为指向有效对象：

```C++
#include <iostream>

int main()
{
    int* ptr {}; // ptr 是空指针

    int x { 5 };
    ptr = &x; // ptr 现在指向 x

    std::cout << *ptr << '\n'; // 解引用ptr，打印x
 
    return 0;
}
```

如果不是用有效对象的地址初始化指针，则将其置空。

### 7. nullptr关键字

就像关键字true和false表示布尔字面值一样，nullptr关键字表示空指针字面值。可以使用nullptr显式地初始化指针或为指针分配null值。

```
int main()
{
	int* ptr {nullptr};
	
	int value {5};
	int* ptr2 {&value};
	ptr2 = nullptr;
	
	someFunction(nullptr); // 可以将nullptr作为函数参数传递
	return 0;
}
```

在上面的示例中，我们使用赋值将ptr2的值设置为nullptr，使ptr2成为空指针。

### 8.检查空指针

就像可以使用条件语句来测试布尔值的true或false一样，也可以使用条件语句测试指针是否具有值nullptr：

```
#include <iostream>

int main()
{
	int x {5};
	int* ptr {&x};
	
	if(ptr== nullptr)
	{
		std::cout << "ptr is null"<< "\n";
	}else{
		std::cout << "ptr is no-null"<< "\n";
	}
	return 0;
}
```

### 9.尽可能支持引用而不是指针

指针具有额外的能力，可以更改它们所指向的内容，并指向null。然而，这些指针功能本身也是危险的：空指针有被解引用的风险，并且更改指针指向的内容的功能可以使创建悬空指针变得更容易.

## 12.9 指针与常量

### 1.指向常量值的指针

常量指针是指向常量值的指针。

要声明指向常量值的指针，请在指针的数据类型之前使用const关键字：

```C++
int main()
{
    const int x{5};
    const int* ptr {&x};
    
    *ptr=6;  //error、不被允许
    return 0;
}
```

在上面的示例中，ptr指向常量int。由于所指向的数据类型是常量，因此无法更改所指向的值。

然而，由于指向常量的指针本身不是常量（它只是指向常量值），因此我们可以通过为指针分配新地址来更改指针所指向的内容：

```C++
int main()
{
    const int x{ 5 };
    const int* ptr { &x }; // ptr 指向 const int x

    const int y{ 6 };
    ptr = &y; // okay: ptr 现在指向 const int y

    return 0;
}
```

就像const引用一样，常量指针实际可以指向非const变量。常量指针将所指向的值视为常量，而不管该地址处的对象最初是否定义为常量：

```C++
int main()
{
    int x{ 5 }; // non-const
    const int* ptr { &x }; // ptr 指向 "const int"

    *ptr = 6;  // 不被允许: ptr 指向 "const int" ，所以不能通过ptr修改指向的对象
    x = 6; // ok: x是非const，所以仍然可以通过 x 这个标识符来修改实际的对象

    return 0;
}
```

### 2.指针常量（const 指针）
