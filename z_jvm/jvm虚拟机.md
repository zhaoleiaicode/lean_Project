# 第一章  JVM体系架构

## 1、Java-跨平台的语言

系统软件无法通用是一个常见的问题。但使用过 Java 的同学都知道，Java 代码可以在服务端（Linux 系统）运行，也可以在 Windows 系统运行，但我们并没有生成多份不同的代码。所以 Java 语言是如何做到的呢？

Java 语言并不直接将代码编译成与系统有关的机器码，而是编译成一种特定的语言规范，这种语言规范我们称之为字节码。无论 Java 程序要在 Windows 系统，还是 Mac OSX 系统，抑或是 Linux 系统，它首先都得编译成字节码文件，之后才能运行。

但即使编译成字节码文件了，各个系统还是无法明白字节码文件的内容，这时候就需要 Java 虚拟机的帮助了。Java 虚拟机会解析字节码文件的内容，并将其翻译为各操作系统能理解的机器码。

![](https://github.com/zlrobot-start/cpp_Project/blob/main/z_jvm/images/%E5%8A%A0%E8%BD%BD%E5%9B%BE.drawio.svg)

在 Java 虚拟机还没出现之前，为了支持软件在不同系统上运行，我们必须在多个平台写多份代码，分别对应特定的系统。但 Java 虚拟机出现之后，你只需要按照特定规范编译书写，编译器编译成字节码文件后，虚拟机会帮你将字节码生成对应的 Windows Code 和 Mac Code。本质上最终还是会生成 Windows Code 和 Mac Code 两份机器代码，但对于开发人员来说，却只需要写一次代码了。Java 虚拟机帮开发人员承担了重复的工作，让开发效率更高了。

Java是目前应用最为广泛的软件开发平台之一。随着Java以及Java社区的不断壮大Java 也早已不再是简简单单的一门计算机语言了，它更是一个平台、一种文化、一个社区。

很多初学者关于 Java 虚拟机有一个误区，他们会觉得 Java 虚拟机只能运行 Java 代码。* 但实际上 Java 虚拟机运行的是字节码文件。*换句话说，如果你用 其他 语言写一段代码，并自己用特定编译器能生成符合字节码规范的字节码文件，那么 Java 虚拟机也是可以运行的。

![](https://github.com/zlrobot-start/cpp_Project/blob/main/z_jvm/images/JVMp%E5%B9%B3%E5%8F%B0%20-002.drawio.svg)

Groovy、Scala、JRuby、Kotlin等都是Java平台的一部分。所以说JVM本身是跨语言的一个平台。所以虽然名字是 Java 虚拟机，但 Java 虚拟机与 Java 语言没有直接关系，它只按照 Java 虚拟机规范去读取 Class 文件，并按照规定去解析、执行字节码指令，仅此而已。

**总结来讲**：

1、随着Java7的正式发布，Java虚拟机的设计者们通过JSR-292规范基本实现在Java虚拟机平台上运行非Java语言编写的程序。

2、Java虚拟机根本不关心运行在其内部的程序到底是使用何种编程语言编写的，它只关心“字节码”文件。也就是说Java虚拟机拥有语言无关性，并不会单纯地与Java语言“终身绑定”，只要其他编程语言的编译结果满足并包含Java虚拟机的内部指令集、符号表以及其他的辅助信息，它就是一个有效的字节码文件，就能够被虚拟机所识别并装载运行。

3、我们平时说的java字节码，指的是用java语言编译成的字节码。准确的说任何能在jvm平台上执行的字节码格式都是一样的。所以应该统称为：jvm字节码。

4、Java虚拟机与Java语言并没有必然的联系，它只与特定的二进制文件格式——Class文件格式所关联，Class文件中包含了Java虚拟机指令集（或者称为字节码、Bytecodes）和符号表，还有一些其他辅助信息。

5、对这些运行于Java虚拟机之上、Java之外的语言，来自系统级的、底层的支持正在迅速增强，以JSR-292为核心的一系列项目和功能改进（如DaVinci Machine项目、Nashorn引擎、InvokeDynamic指令、java.lang.invoke包等），推动Java虚拟机从“Java语言的虚拟机”向 “多语言虚拟机”的方向发展。。

6、Java平台上的多语言混合编程正成为主流，通过特定领域的语言去解决特定领域的问题是当前软件开发应对日趋复杂的项目需求的一个方向。

## 2、Java-代码到机器码

Java虚拟机就是二进制字节码的运行环境，负责装载字节码到其内部，解释/编译为对应平台上的机器码执行。无论什么语言写的代码，其到最后都是通过机器码运行的，无一例外。那么对于 Java 语言来说，其从源代码到机器码，这中间到底发生了什么呢？

编译器可以分为：**前端编译器、JIT 编译器和AOT编译器**。

首先是前端编译器，其代表为JDK自带的**Javac编译器**，负责将Java源代码编译成字节码。其次，JIT编译器，作为虚拟机性能的关键组件，它能在运行时将热点代码编译成机器码，提升执行效率。最后，AOT编译器，作为一种插入式注释处理器，能够在编译时期将Java代码转化为机器码，优化执行性能。

### 2.1 前端编译器(代码到字节码)

对于 Java 虚拟机来说，其实际输入的是字节码文件，而不是 Java 文件。那么对于 Java 语言而言，其实怎么将 Java 代码转化成字节码文件的呢？我们知道在 JDK 的安装目录里有一个 javac 工具，就是它将 Java 代码翻译成字节码，这个工具我们叫做编译器。相对于后面要讲的其他编译器，其因为处于编译的前期，因此又被成为前端编译器。

![](https://github.com/zlrobot-start/cpp_Project/blob/main/z_jvm/images/%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E5%99%A8.drawio.svg)

优点：

- 这阶段的优化是指程序编码方面的；
- 许多Java语法新特性（"语法糖"：泛型、内部类等等），是靠前端编译器实现的,而不是依赖虚拟机；
- 编译成的Class文件可以直接给JVM解释器解释执行，省去编译时间，加快启动速度；

缺点:

- 对代码运行效率几乎没有任何优化措施；
- 解释执行效率较低，所以需要结合下面的JIT编译；  

以代码为例:

```
public class Test{
   public static void main(String args[]){
        System.out.println("Hello World!");
   }
}
```

使用 javac 命令编译上面这个类，便会生成一个 Test.class 文件：

```
> javac Demo.java
> ls 
Test.java Test.class
```

行 javac 命令的过程，其实就是 javac 编译器解析 Java 源代码，并生成字节码文件的过程。说白了，其实就是使用 javac 编译器把 Java 语言规范转化为字节码语言规范。javac 编译器的处理过程可以分为下面四个阶段：

1、词法、语法分析。在这个阶段，javac 编译器会对源代码的字符进行一次扫描，最终生成一个抽象的语法树。简单地说，在这个阶段 javac 编译器会搞懂我们的代码到底想要干嘛。就像我们分析一个句子一样，我们会对句子划分主谓宾，弄清楚这个句子要表达的意思一样。

2、填充符号表。我们知道类之间是会互相引用的，但在编译阶段，我们无法确定其具体的地址，所以我们会使用一个符号来替代。在这个阶段做的就是类似的事情，即对抽象的类或接口进行符号填充。等到类加载阶段，javac 编译器会将符号替换成具体的内存地址。

3、注解处理。我们知道 Java 是支持注解的，因此在这个阶段会对注解进行分析，根据注解的作用将其还原成具体的指令集。

4、分析与字节码生成。到了这个阶段，javac 编译器便会根据上面几个阶段分析出来的结果，进行字节码的生成，最终输出为 class 文件。

我们一般称 javac 编译器为前端编译器，因为其发生在整个编译的前期。常见的前端编译器有 Sun 的 javac，Eclipse JDT 的增量式编译器（ECJ）。

### 2.2 JIT编译器(从字节码到机器码)
