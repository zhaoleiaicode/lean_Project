# 第一章  JVM体系架构

## 1、Java-跨平台的语言

系统软件无法通用是一个常见的问题。但使用过 Java 的同学都知道，Java 代码可以在服务端（Linux 系统）运行，也可以在 Windows 系统运行，但我们并没有生成多份不同的代码。所以 Java 语言是如何做到的呢？

Java 语言并不直接将代码编译成与系统有关的机器码，而是编译成一种特定的语言规范，这种语言规范我们称之为字节码。无论 Java 程序要在 Windows 系统，还是 Mac OSX 系统，抑或是 Linux 系统，它首先都得编译成字节码文件，之后才能运行。

但即使编译成字节码文件了，各个系统还是无法明白字节码文件的内容，这时候就需要 Java 虚拟机的帮助了。Java 虚拟机会解析字节码文件的内容，并将其翻译为各操作系统能理解的机器码。

![](https://github.com/zlrobot-start/cpp_Project/blob/main/z_jvm/images/%E5%8A%A0%E8%BD%BD%E5%9B%BE.drawio.svg)

在 Java 虚拟机还没出现之前，为了支持软件在不同系统上运行，我们必须在多个平台写多份代码，分别对应特定的系统。但 Java 虚拟机出现之后，你只需要按照特定规范编译书写，编译器编译成字节码文件后，虚拟机会帮你将字节码生成对应的 Windows Code 和 Mac Code。本质上最终还是会生成 Windows Code 和 Mac Code 两份机器代码，但对于开发人员来说，却只需要写一次代码了。Java 虚拟机帮开发人员承担了重复的工作，让开发效率更高了。

Java是目前应用最为广泛的软件开发平台之一。随着Java以及Java社区的不断壮大Java 也早已不再是简简单单的一门计算机语言了，它更是一个平台、一种文化、一个社区。

很多初学者关于 Java 虚拟机有一个误区，他们会觉得 Java 虚拟机只能运行 Java 代码。* 但实际上 Java 虚拟机运行的是字节码文件。*换句话说，如果你用 其他 语言写一段代码，并自己用特定编译器能生成符合字节码规范的字节码文件，那么 Java 虚拟机也是可以运行的。

![](https://github.com/zlrobot-start/cpp_Project/blob/main/z_jvm/images/JVMp%E5%B9%B3%E5%8F%B0%20-002.drawio.svg)

Groovy、Scala、JRuby、Kotlin等都是Java平台的一部分。所以说JVM本身是跨语言的一个平台。所以虽然名字是 Java 虚拟机，但 Java 虚拟机与 Java 语言没有直接关系，它只按照 Java 虚拟机规范去读取 Class 文件，并按照规定去解析、执行字节码指令，仅此而已。

**总结来讲**：

1、随着Java7的正式发布，Java虚拟机的设计者们通过JSR-292规范基本实现在Java虚拟机平台上运行非Java语言编写的程序。

2、Java虚拟机根本不关心运行在其内部的程序到底是使用何种编程语言编写的，它只关心“字节码”文件。也就是说Java虚拟机拥有语言无关性，并不会单纯地与Java语言“终身绑定”，只要其他编程语言的编译结果满足并包含Java虚拟机的内部指令集、符号表以及其他的辅助信息，它就是一个有效的字节码文件，就能够被虚拟机所识别并装载运行。

3、我们平时说的java字节码，指的是用java语言编译成的字节码。准确的说任何能在jvm平台上执行的字节码格式都是一样的。所以应该统称为：jvm字节码。

4、Java虚拟机与Java语言并没有必然的联系，它只与特定的二进制文件格式——Class文件格式所关联，Class文件中包含了Java虚拟机指令集（或者称为字节码、Bytecodes）和符号表，还有一些其他辅助信息。

5、对这些运行于Java虚拟机之上、Java之外的语言，来自系统级的、底层的支持正在迅速增强，以JSR-292为核心的一系列项目和功能改进（如DaVinci Machine项目、Nashorn引擎、InvokeDynamic指令、java.lang.invoke包等），推动Java虚拟机从“Java语言的虚拟机”向 “多语言虚拟机”的方向发展。。

6、Java平台上的多语言混合编程正成为主流，通过特定领域的语言去解决特定领域的问题是当前软件开发应对日趋复杂的项目需求的一个方向。

## 2、Java-代码到机器码

Java虚拟机就是二进制字节码的运行环境，负责装载字节码到其内部，解释/编译为对应平台上的机器码执行。无论什么语言写的代码，其到最后都是通过机器码运行的，无一例外。那么对于 Java 语言来说，其从源代码到机器码，这中间到底发生了什么呢？

编译器可以分为：**前端编译器、JIT 编译器和AOT编译器**。

首先是前端编译器，其代表为JDK自带的**Javac编译器**，负责将Java源代码编译成字节码。其次，JIT编译器，作为虚拟机性能的关键组件，它能在运行时将热点代码编译成机器码，提升执行效率。最后，AOT编译器，作为一种插入式注释处理器，能够在编译时期将Java代码转化为机器码，优化执行性能。

### 2.1 前端编译器(代码到字节码)

对于 Java 虚拟机来说，其实际输入的是字节码文件，而不是 Java 文件。那么对于 Java 语言而言，其实怎么将 Java 代码转化成字节码文件的呢？我们知道在 JDK 的安装目录里有一个 javac 工具，就是它将 Java 代码翻译成字节码，这个工具我们叫做编译器。相对于后面要讲的其他编译器，其因为处于编译的前期，因此又被成为前端编译器。

![](https://github.com/zlrobot-start/cpp_Project/blob/main/z_jvm/images/%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E5%99%A8.drawio.svg)

优点：

- 这阶段的优化是指程序编码方面的；
- 许多Java语法新特性（"语法糖"：泛型、内部类等等），是靠前端编译器实现的,而不是依赖虚拟机；
- 编译成的Class文件可以直接给JVM解释器解释执行，省去编译时间，加快启动速度；

缺点:

- 对代码运行效率几乎没有任何优化措施；
- 解释执行效率较低，所以需要结合下面的JIT编译；  

以代码为例:

```
public class Test{
   public static void main(String args[]){
        System.out.println("Hello World!");
   }
}
```

使用 javac 命令编译上面这个类，便会生成一个 Test.class 文件：

```
> javac Demo.java
> ls 
Test.java Test.class
```

行 javac 命令的过程，其实就是 javac 编译器解析 Java 源代码，并生成字节码文件的过程。说白了，其实就是使用 javac 编译器把 Java 语言规范转化为字节码语言规范。javac 编译器的处理过程可以分为下面四个阶段：

1、词法、语法分析。在这个阶段，javac 编译器会对源代码的字符进行一次扫描，最终生成一个抽象的语法树。简单地说，在这个阶段 javac 编译器会搞懂我们的代码到底想要干嘛。就像我们分析一个句子一样，我们会对句子划分主谓宾，弄清楚这个句子要表达的意思一样。

2、填充符号表。我们知道类之间是会互相引用的，但在编译阶段，我们无法确定其具体的地址，所以我们会使用一个符号来替代。在这个阶段做的就是类似的事情，即对抽象的类或接口进行符号填充。等到类加载阶段，javac 编译器会将符号替换成具体的内存地址。

3、注解处理。我们知道 Java 是支持注解的，因此在这个阶段会对注解进行分析，根据注解的作用将其还原成具体的指令集。

4、分析与字节码生成。到了这个阶段，javac 编译器便会根据上面几个阶段分析出来的结果，进行字节码的生成，最终输出为 class 文件。

我们一般称 javac 编译器为前端编译器，因为其发生在整个编译的前期。常见的前端编译器有 Sun 的 javac，Eclipse JDT 的增量式编译器（ECJ）。

### 2.2 JIT编译器(从字节码到机器码)
当源代码转化为字节码之后，其实要运行程序，有两种选择。一种是使用 Java 解释器解释执行字节码，另一种则是使用 JIT 编译器将字节码转化为本地机器代码。

两种方式的区别在于，前者启动速度快但运行速度慢，而后者启动速度慢但运行速度快。至于为什么会这样，其原因很简单。因为解释器不需要像 JIT 编译器一样，将所有字节码都转化为机器码，自然就少去了优化的时间。而当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。所以在实际情况中，为了运行速度以及效率，我们通常采用两者相结合的方式进行 Java 代码的编译执行。

![](https://github.com/zlrobot-start/cpp_Project/blob/main/z_jvm/images/JIN%E5%8A%A0%E8%BD%BD%E5%99%A8003.drawio.svg)

在 HotSpot 虚拟机内置了两个即时编译器，分别称为 Client Compiler 和Server Compiler。这两种不同的编译器衍生出两种不同的编译模式，我们分别称之为：C1 编译模式，C2 编译模式。

**那么 C1 编译模式和 C2 编译模式有什么区别呢？**

C1 编译模式会将字节码编译为本地代码，进行简单、可靠的优化，如有必要将加入性能监控的逻辑。而 C2 编译模式，也是将字节码编译为本地代码，但是会启用一些编译耗时较长的优化，甚至会根据性能监控信息进行一些不可靠的激进优化。

简单地说 C1 编译模式做的优化相对比较保守，其编译速度相比 C2 较快。而 C2 编译模式会做一些激进的优化，并且会根据性能监控做针对性优化，所以其编译质量相对较好，但是耗时更长。

实际上对于 HotSpot 虚拟机来说，其一共有三种运行模式可选，分别是：

- 混合模式（Mixed Mode） 。即 C1 和 C2 两种模式混合起来使用，这是默认的运行模式。如果你想单独使用 C1 模式或 C2 模式，使用 `-client` 或 `-server` 打开即可。【采用解释器和JIT编译器并存的方式共同执行程序，这是默认模式‌】
- 解释模式（Interpreted Mode）。即所有代码都解释执行，使用 `-Xint` 参数可以打开这个模式。【完全采用解释器模式执行程序，不使用JIT编译器‌】
- 编译模式（Compiled Mode）。 此模式优先采用编译，但是无法编译时也会解释执行，使用 `-Xcomp` 打开这种模式。【完全采用即时编译器模式执行程序，如果即时编译出现问题，解释器会介入执行‌】

在命令行中输入 `java -version` 可以看到，我机器上的虚拟机使用 Mixed Mode 运行模式。
![](https://github.com/zlrobot-start/cpp_Project/blob/main/z_jvm/images/javaversion.png)
### 2.3 AOT 编译器：源代码到机器码

Java 中还有一个 AOT 编译器，它能直接将源代码转化为机器码。AOT 编译器的基本思想是：在程序执行前生成 Java 方法的本地代码，以便在程序运行时直接使用本地代码。但是 Java 语言本身的动态特性带来了额外的复杂性，影响了 Java 程序静态编译代码的质量。例如 Java 语言中的动态类加载，因为 AOT 是在程序运行前编译的，所以无法获知这一信息，所以会导致一些问题的产生。类似的问题还有很多。

总的来说，AOT 编译器从编译质量上来看，肯定比不上 JIT 编译器。其存在的目的在于避免 JIT 编译器的运行时性能消耗或内存消耗，或者避免解释程序的早期性能开销。在运行速度上来说，AOT 编译器编译出来的代码比 JIT 编译出来的慢，但是比解释执行的快。而编译时间上，AOT 也是一个始终的速度。所以说，AOT 编译器的存在是 JVM 牺牲质量换取性能的一种策略。就如 JVM 其运行模式中选择 Mixed 混合模式一样，使用 C1 编译模式只进行简单的优化，而 C2 编译模式则进行较为激进的优化。充分利用两种模式的优点，从而达到最优的运行效率。

总结:

* 在 JVM 中有三个非常重要的编译器，它们分别是：前端编译器、JIT 编译器、AOT 编译器。
* 前端编译器，最常见的就是我们的 javac 编译器，其将 Java 源代码编译为 Java 字节码文件。
* JIT 即时编译器，最常见的是 HotSpot 虚拟机中的 Client Compiler 和 Server Compiler，其将 Java 字节码编译为本地机器代码。
* 而 AOT 编译器则能将源代码直接编译为本地机器码。
* 这三种编译器的编译速度和编译质量如下：
  * 编译速度上，解释执行 > AOT 编译器 > JIT 编译器。
  * 编译质量上，JIT 编译器 > AOT 编译器 > 解释执行。

而在 JVM 中，通过这几种不同方式的配合，使得 JVM 的编译质量和运行速度达到最优的状态。
